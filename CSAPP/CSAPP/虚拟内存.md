# 物理内存

**物理内存**是指计算机中实际存在的随机存取存储器（RAM）。它是一个直接与中央处理器（CPU）进行数据交互的硬件资源，用于存储当前正在运行的程序及其所需的数据。虚拟内存扩展了物理内存的能力，使得即使物理内存不足，系统仍然可以运行较大的程序。物理内存为虚拟内存提供高速支持，提高了整体性能。

| **属性** | **物理内存** | **虚拟内存** |
| -------- | ------------ | ------------ |
| **存在形式** | 硬件（RAM） | 软件技术 |
| **容量** | 受限于硬件配置 | 由物理内存和磁盘空间共同构成，容量大 |
| **速度** | 速度快，直接被CPU访问 | 速度较慢，依赖硬盘存储 |
| **地址类型** | 物理地址 | 虚拟地址 |


# 虚拟内存

**虚拟内存**是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，为每个进程提供了一个大的、一致的和私有的地址空间。程序使用虚拟地址，虚拟内存系统将其动态映射到物理地址，提供了一种间接的内存访问方式。

它将主存视为一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，高效地使用了主存。为每个进程提供了一致的地址空间，简化了内存管理，且保护了每个进程的地址空间不被其他进程破坏。

虚拟内存提供了三个重要的能力：

1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。
2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。
3. 它保护了每个进程的地址空间不被其他进程破坏。

# 页表

**页表（Page Table）**是操作系统中的一种数据结构，用于维护虚拟地址和物理地址之间的映射关系。页表是虚拟内存系统中的关键数据结构，用于将虚拟地址映射到物理地址。页表中的每个条目（PTE）包含了虚拟页的相关信息，如有效位（表明虚拟页是否在主存中）、物理页帧号（若在主存中）以及其他控制和状态位（如修改位、访问位、权限位等）。通过页表，系统能够快速确定虚拟页在主存中的位置，实现高效的地址转换和缓存管理。

**页表的核心作用是将虚拟页号（VPN，Virtual Page Number）映射到页框号（PFN，Page Frame Number），从而完成虚拟地址到物理地址的转换。**

页表的每一项称为页表条目（PTE, Page Table Entry），通常包含以下信息：

1. **页框号（Page Frame Number, PFN）**：映射到物理内存的具体页框。

2. **有效位（Valid Bit）**

   ：指示该虚拟页是否驻留在物理内存中。

   - 有效：页面在物理内存中，可直接访问。
   - 无效：页面在磁盘中，需要触发缺页中断。

3. **访问权限（Access Rights）**：限制对页面的操作类型，如读、写、执行。

4. **修改位（Dirty Bit）**：指示页面内容是否被修改，决定是否需要回写到磁盘。

5. **引用位（Reference Bit）**：标识页面是否最近被访问，用于页面替换算法。

6. **分页级别信息**（多级页表情况下）：指向下一级页表的指针。

<img src="https://s2.loli.net/2024/12/02/qauj1fnplY2z3BA.png" alt=" 2024-12-02 230247.png" style="zoom:50%;" /> 

## 页命中

**页命中（Page Hit）**是指在地址转换时，操作系统发现需要访问的虚拟页面已经驻留在物理内存中。当 CPU 引用一个虚拟地址时，首先由硬件（内存管理单元，MMU）根据页表进行地址翻译。若虚拟页的有效位为 1，表示该虚拟页在主存中，此时从页表中获取对应的物理页帧号，与虚拟地址中的页内偏移量组合，形成物理地址，然后可以直接从主存中读取或写入数据。页命中时，内存访问速度较快，与直接访问主存类似。

<img src="https://s2.loli.net/2024/12/02/qauj1fnplY2z3BA.png" alt=" 2024-12-02 230247.png" style="zoom:50%;" /> 

对 VP 2 中一个字的引用就会命中。

## 缺页

**缺页**是指在地址转换时，操作系统发现需要访问的虚拟页面不在物理内存中。若虚拟页的有效位为 0，则发生缺页异常。此时，控制转移到内核的缺页异常处理程序。缺页处理程序会选择一个牺牲页（如果物理内存已满），将其置换到磁盘（如果该页已被修改过），然后从磁盘中将所需的虚拟页调入物理内存中的一个空闲页帧，更新页表（设置有效位、页帧号等信息），最后重新执行导致缺页的指令。缺页处理涉及磁盘 I/O 操作，相对较慢，会对程序的执行性能产生一定影响。

<img src="https://s2.loli.net/2024/12/02/qauj1fnplY2z3BA.png" alt=" 2024-12-02 230247.png" style="zoom:50%;" /> 

对 VP3 中的字的引用会不命中，从而触发了缺页。

<img src="https://s2.loli.net/2024/12/02/dKCGVsLBbDjy7pr.png" alt="image.png" style="zoom:50%;" /> 

缺页处理程序选择 VP 4 作为牺牲页，并从磁盘上用 VP 3 的副本取代它。在缺页处理程序重新启动导致缺页的指令之后，该指令将从内存中正常地读取字，而不会再产生异常。

## 分配页面

页面分配是操作系统为进程分配物理内存页面的过程。

<img src="https://s2.loli.net/2024/12/02/HOmIZKhkDLpVuST.png" alt=" 2024-12-02 230257.png" style="zoom:50%;" /> 

内核在磁盘上分配 VP 5，并且将 PTE 5 指向这个新的位置。

## TLB

**快速表**（TLB, Translation Lookaside Buffer）是一种缓存机制，存储最近使用的虚拟地址到物理地址的映射。其目的是减少地址转换的延迟，提高系统性能。

<img src="https://s2.loli.net/2024/12/03/gcAUnse1DLyKf8l.png" alt="image _5_.png" style="zoom:67%;" /> 

当CPU访问虚拟地址时，首先查询TLB。如果映射存在，直接获取物理地址，访问内存。如果映射不存在，进行页表查找，获取物理地址，并将映射添加到TLB。

<img src="https://s2.loli.net/2024/12/03/iwWckYLAS8Iso6H.png" alt="image _4_.png" style="zoom: 33%;" /> 

## 多级页表

**多级页表**是一种内存管理机制，用于将虚拟地址空间映射到物理地址空间。通过将页表分为多级结构，操作系统可以有效管理大规模的虚拟内存，减少内存占用。

 将虚拟地址分为多个部分，每部分对应页表的一个级别。例如，在两级页表中，虚拟地址分为页目录索引和页表索引。CPU根据虚拟地址的各部分，依次查找对应级别的页表，最终获取物理页框号。只有在需要时，才分配相应级别的页表，避免了为整个虚拟地址空间分配单一大页表的内存浪费。

<img src="https://s2.loli.net/2024/12/03/sf7CBIxZ1QyeMgO.png" alt="image123123.png" style="zoom: 40%;" />  

<img src="https://s2.loli.net/2024/12/03/XGAgBHz8IbRpDhY.png" alt="image _1_.png" style="zoom:50%;" /> 

# 地址翻译

下图展示了 MMU 如何利用页表来实现这种映射。CPU 中的一个控制寄存器，**页表基址寄存器**（Page Table Base Register，PTBR）指向当前页表。n 位的虚拟地址包含两个部分：一个 p 位的**虚拟页面偏移**（Virtual Page Offset，VPO）和一个(n−p)位的**虚拟页号**（Virtual Page Number，VPN）。MMU 利用 VPN 来选择适当的 PTE。例如，VPN 0 选择 PTE 0，VPN 1 选择 PTE 1，以此类推。将页表条目中**物理页号**（Physical Page Number，PPN）和虚拟地址中的 VPO 串联起来，就得到相应的物理地址。注意，因为物理和虚拟页面都是 P 字节的，所以**物理页面偏移**（Physical Page Offset，PPO）和 VPO 是相同的。

<img src="https://s2.loli.net/2024/12/03/jK6PxTSQqopDWkh.png" alt="image _2_.png" style="zoom: 50%;" /> 

下图展示了当页面命中时，CPU 硬件执行的步骤。

- **第 1 步：**处理器生成一个虚拟地址，并把它传送给 MMU。
- **第 2 步：**MMU 生成 PTE 地址，并从高速缓存/主存请求得到它。
- **第 3 步：**高速缓存/主存向 MMU 返回 PTE。
- **第 4 步：**MMU 构造物理地址，并把它传送给高速缓存/主存。
- **第 5 步：**高速缓存/主存返回所请求的数据字给处理器。

<img src="https://s2.loli.net/2024/12/03/8NZm6rzGC79tEnx.png" alt="image _3_.png" style="zoom:50%;" /> 

**虚拟内存是对主存的一个抽象。支持虚拟内存的处理器通过使用一种叫做虚拟寻址的间接形式来引用主存。处理器产生一个虚拟地址，在被发送到主存之前，这个地址被翻译成一个物理地址。从虚拟地址空间到物理地址空间的地址翻译要求硬件和软件紧密合作。专门的硬件通过使用页表来翻译虚拟地址，而页表的内容是由操作系统提供的。**

**虚拟内存提供三个重要的功能。第一，它在主存中自动缓存最近使用的存放磁盘上的虚拟地址空间的内容。虚拟内存缓存中的块叫做页。对磁盘上页的引用会触发缺页，缺页将控制转移到操作系统中的一个缺页处理程序。缺页处理程序将页面从磁盘复制到主存缓存，如果必要，将写回被驱逐的页。第二，虚拟内存简化了内存管理，进而又简化了链接、在进程间共享数据、进程的内存分配以及程序加载。最后，虚拟内存通过在每条页表条目中加入保护位，从而了简化了内存保护。**

**地址翻译的过程必须和系统中所有的硬件缓存的操作集成在一起。大多数页表条目位于 L1 高速缓存中，但是一个称为 TLB 的页表条目的片上高速缓存，通常会消除访问在 L1 上的页表条目的开销。**

# Linux虚拟内存系统

Linux 为每个进程维护单独虚拟地址空间，包含常见的代码、数据、堆、共享库、栈段等，且内核虚拟内存位于用户栈之上，部分区域被映射到所有进程共享的物理页面，还有些区域含各进程不同的数据。

<img src="https://s2.loli.net/2024/12/03/oxRzOWEme6FCZnS.png" style="zoom: 67%;" /> 

内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理页面。例如，每个进程共享内核的代码和全局数据结构。有趣的是，Linux 也将一组连续的虚拟页面（大小等于系统中 DRAM 的总量）映射到相应的一组连续的物理页面。这就为内核提供了一种便利的方法来访问物理内存中任何特定的位置，例如，当它需要访问页表，或在一些设备上执行内存映射的 I/O 操作，而这些设备被映射到特定的物理内存位置时。

内核虚拟内存的其他区域包含每个进程都不相同的数据。比如说，页表、内核在进程的上下文中执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。

## Linux 虚拟内存区域

任务结构中的一个条目指向 **mm_struct**，它描述了虚拟内存的当前状态。其中 **pgd** 指向第一级页表（页全局目录）的基址，而 **mmap** 指向一个 **vm_area_structs**（区域结构）的链表，其中每个 vm_area_structs 都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时，就将 pgd 存放在 CR3 控制寄存器中。

- **task_struct：**表示一个进程的主要结构体，用于存储与进程相关的所有信息。

- **mm_struct：**关联于 `task_struct` 的内存管理结构，包含与进程内存相关的信息

- **vm_area_struct：**表示进程虚拟内存中的一个内存区域（如代码段、数据段或共享库）。

  - **vm_start**：指向这个区域的起始处。

  - **vm_end**：指向这个区域的结束处。

  - **vm_prot**：描述这个区域内包含的所有页的读写许可权限。

  - **vm_flags**：描述这个区域内的页面是与其他进程共享的，还是这个进程私有的（还描述了其他一些信息）。

  - **vm_next**：指向链表中下—区域结构。


<img src="https://s2.loli.net/2024/12/03/PCFEd5nqpw6c3GB.png" alt="image _1_.png" style="zoom: 67%;" /> 

## Linux 缺页异常处理

- 当 MMU 翻译虚拟地址 A 触发缺页异常，处理程序会进行系列判断：先判断 A 是否在某个区域结构定义区域内，若不合法则触发段错误终止进程；再判断试图进行的内存访问是否合法，若不合法则触发保护异常终止进程。
- 若缺页是对合法虚拟地址进行合法操作造成的，处理程序会选择牺牲页面，进行换出换入及更新页表操作，返回后 CPU 重新启动引起缺页的指令以便 MMU 正常翻译。

<img src="https://s2.loli.net/2024/12/03/nq1zxOpw9bPJTs5.png" alt="image _2_.png" style="zoom: 67%;" /> 

# 内存映射

**内存映射概念**：Linux 通过将虚拟内存区域与磁盘上的对象关联来初始化该区域内容，此过程即内存映射。

可映射的对象类型及处理：

- **普通文件**：虚拟内存区域可映射到 Linux 文件系统中的普通文件（如可执行目标文件）的连续部分，文件区按页大小划分，虚拟页面按需调入物理内存，若区域比文件区大，剩余部分用零填充。
- **匿名文件**：区域也可映射到内核创建的匿名文件，其内容全是二进制零。CPU 首次引用该区域内虚拟页面时，内核会在物理内存找牺牲页面处理，无磁盘与内存间实际数据传送，此类页面有时叫请求二进制零的页。

**虚拟页面后续处理**：无论哪种映射情况，初始化后的虚拟页面会在由内核维护的专门交换文件（也叫交换空间或交换区域）之间进行调换，且交换空间会限制当前运行进程能分配的虚拟页面总数。

## 共享对象

内存映射概念源于将虚拟内存系统集成到传统文件系统，可提供高效加载程序和数据到内存的方法。进程抽象虽能提供私有虚拟地址空间，但许多进程有相同只读代码区域，若各进程都在物理内存保留常用代码副本会造成浪费，而内存映射可控制多进程共享对象。

- **共享对象**：一个对象可作为共享对象映射到虚拟内存区域，一个进程对该区域的写操作对其他映射此共享对象的进程可见，且变化会反映在磁盘原始对象中，多个进程映射共享对象时，物理内存只需存放其一个副本。
- **私有对象**：映射到私有对象的区域改变对其他进程不可见，写操作也不反映在磁盘对象中。私有对象使用写时复制技术映射，初始时物理内存只存一份副本，相应页表条目标记为只读、区域结构标记为私有的写时复制，当有进程试图写时会触发保护故障，故障处理程序会创建新副本、更新页表并恢复可写权限，写时复制可充分利用稀有物理内存。

<img src="https://s2.loli.net/2024/12/03/xMVr7OPbuGcZLSA.png" alt="image _3_.png" style="zoom: 50%;" /> 

<center>一个共享对象（注意，物理页面不一定是连续的）</center>

<img src="https://s2.loli.net/2024/12/03/sadGVKmZMSPc4Cf.png" alt="image _4_.png" style="zoom:50%;" />

<center>一个私有的写时复制对象</center>

## fork函数

在理解虚拟内存与内存映射后，能明确 fork 函数创建新进程及独立虚拟地址空间的方式。

当当前进程调用 fork 函数时：

- 内核会为新进程创建各类数据结构并分配唯一的 PID。
- 为新进程创建虚拟内存时，会复制当前进程的 mm_struct、区域结构和页表，且将两个进程的每个页面标记为只读，每个区域结构标记为私有的写时复制。

当 fork 在新进程中返回时，新进程的虚拟内存与调用 fork 时的当前进程虚拟内存相同。之后若两个进程中任一个进行写操作，写时复制机制就会创建新页面，以此维持每个进程私有地址空间的抽象概念。

## execve函数

当运行程序执行 `execve ("a.out", NULL, NULL);` 时，execve 函数会在当前进程中加载并运行 a.out 中的程序以替代当前程序，具体步骤如下：

- **删除已存在的用户区域**：删除当前进程虚拟地址用户部分已有的区域结构。
- **映射私有区域**：为新程序的代码、数据、bss 和栈等区域创建新的区域结构，这些区域都是私有的、写时复制的。其中代码和数据区域映射为 a.out 文件中的.text 和.data 区，bss 区域映射到匿名文件且是请求二进制零的，栈和堆区域也是请求二进制零且初始长度为零。
- **映射共享区域**：若 a.out 程序与如标准 C 库 libc.so 等共享对象链接，会将这些共享对象动态链接并映射到用户虚拟地址空间的共享区域内。
- **设置程序计数器（PC）**：execve 最后设置当前进程上下文中的程序计数器，使其指向代码区域的入口点，下次调度该进程时就从该入口点开始执行，且 Linux 会按需换入代码和数据页面。

<img src="https://s2.loli.net/2024/12/03/sBVUij7MIHY6A1R.png" alt="image _5_.png" style="zoom: 50%;" /> 

<center>加载器是如何映射用户地址空间的区域的</center>

## mmap函数

```C
#include <unistd.h>
#include <sys/mman.h>

void *mmap(void *start, size_t length, int prot, int flags,
           int fd, off_t offset);
// 返回：若成功时则为指向映射区域的指针，若出错则为 MAP_FAILED(-1)。
```

- mmap 函数要求内核创建新的虚拟内存区域，可从指定地址 start 开始（通常设为 NULL），将文件描述符 fd 指定对象的连续片映射到新区域，连续片大小为 length 字节，从距文件开始处偏移量为 offset 字节的地方开始。
- 参数 prot 描述新映射区域的访问权限位，有 PROT_EXEC（区域内页面可执行）、PROT_READ（可读）、PROT_WRITE（可写）、PROT_NONE（不可访问）等。
- 参数 flags 描述被映射对象类型，如 MAP_ANON 表示映射匿名对象，相应虚拟页面是请求二进制零的；MAP_PRIVATE 表示映射私有、写时复制的对象；MAP_SHARED 表示映射共享对象。示例展示了如何调用 mmap 函数创建特定类型的虚拟内存区域。

<img src="https://s2.loli.net/2024/12/03/NTmSGZO2DkKlIhY.png" alt="image_7_.png" style="zoom:50%;" /> 

```C
#include <unistd.h>
#include <sys/mman.h>

int munmap(void *start, size_t length);
// 返回：若成功则为 0，若出错则为 -1。
```

- munmap 函数用于删除从虚拟地址 start 开始、由接下来 length 字节组成的区域，若后续对已删除区域有引用会导致段错误。