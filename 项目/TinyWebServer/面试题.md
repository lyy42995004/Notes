# 项目介绍

## 项目背景（为什么要做这样的项目？）

## 项目描述

## 项目流程

## 项目难点

## 项目瓶颈

## 项目优化

## 个人收获

## 烂大街的项目，你如何脱颖而出？

# 高并发架构

## Reactor和Proactor的区别？

## 为什么采用Reactor？

## 讲一下select，poll，epoll？

## epoll 是如何实现高效的事件驱动 I/O 的？

## 说说 epoll 的 LT（水平触发）和 ET（边缘触发）模式，在项目中你使用了哪种模式？为什么？

## 为什么将监听套接字设置为非阻塞？

## CGI机制了解过吗？

## 在高并发情况下，大量图片和视频请求可能会占用大量带宽，你是如何进行带宽管理和优化的？

# HTTP

## 状态机是什么？为什么要用状态机？

状态机其实就是一种**根据当前状态和输入，决定下一步做什么的程序控制方式**。

它把一个复杂的业务流程拆成若干个**有限的状态**，程序在不同状态下，接收到不同输入，就执行对应的动作，并切换到下一个状态。

### 📌 特点：

- **有限个状态**
- **清晰的状态切换规则**
- **根据当前状态+输入，决定行为和下一个状态**

在我的 C++ WebServer 项目中，之所以采用**状态机**，主要是为了**高效、可靠地解析 HTTP 请求报文**。

---

HTTP 报文是由**请求行、请求头和请求体**三部分组成的，且长度不固定、可能分多次到达（粘包、拆包现象），如果直接顺序读取，容易导致解析不完整或混乱。

### 📌 用状态机的作用：

1. **将复杂的解析过程拆分成清晰的阶段**，如：
   - 读取请求行
   - 读取请求头
   - 读取请求体
2. 每次只关注当前阶段的数据是否合法、是否完整，完成后再切换到下一个状态，保证逻辑清晰、代码结构清楚、解析过程可控。
3. **应对报文拆分、多次读取等情况**，避免一条请求报文被拆成多次接收，导致解析失败。
4. 提高服务器的**健壮性和容错性**，遇到非法报文或异常情况时，能准确定位当前状态并及时中断或清理

## 如何处理HTTP请求报文？

1. **接收请求**：
    服务器端使用 `epoll` + `Reactor 模式`监听客户端连接，当检测到有可读事件时，主线程将该事件分发给线程池中的工作线程进行处理。
2. **读取请求报文**：
    工作线程通过 `read` 或 `recv` 函数，将客户端发来的 HTTP 请求报文读取到缓冲区。
3. **解析请求报文**：
    我实现了一个简单的状态机来逐行解析 HTTP 请求：
   - 先解析**请求行**，提取出方法（GET/POST）、URL 路径 和 HTTP 协议版本。
   - 然后逐行解析**请求头**，例如 `Content-Length`、`Connection`、`Host` 等信息。
   - 解析到空行，标志头部结束。
   - 如果是 POST 请求，再根据 `Content-Length` 读取**请求体**。
4. **处理请求**：
    根据解析出的资源路径，判断是：
   - **静态资源请求**（如图片、视频、HTML文件）：
      使用 `mmap` 将文件映射到内存，再通过 `writev` 或 `sendfile` 实现高效的零拷贝发送。
   - **动态请求**（如登录/注册接口）：
      调用后端业务逻辑，可能涉及数据库访问，我实现了**MySQL 连接池**来复用数据库连接，避免频繁建立连接。
5. **构建响应报文**：
    根据处理结果，构造 HTTP 响应报文，包括：
   - **响应行**（HTTP 状态码、协议版本）
   - **响应头**（如 `Content-Type`、`Content-Length`、`Connection`）
   - **空行**
   - **响应体**
6. **发送响应**：
    通过 `write` / `writev` 将响应报文一次性发送给客户端。
7. **处理连接**：
    根据 `Connection` 字段，判断是 `keep-alive` 长连接还是关闭连接：
   - 如果是 `keep-alive`，继续监听新的请求。
   - 否则关闭连接，回收资源。

## 如何保证HTTP请求完整解析？

## HTTP 长连接和短连接区别，项目里怎么支持 keep-alive？

## HTTP 有哪些常见的状态码？在你的项目中是如何处理不同状态码的？

## GET和POST的区别？

## 如何支持HTTP2.0？

## 如何支持HTTPS？

如果我的 C++ WebServer 需要支持 HTTPS，主要有以下几步改造方案：

### 1️⃣ 集成 SSL/TLS 库

我会选择开源的 SSL/TLS 实现库，比如：

- **OpenSSL**（最常用）
- 或者更轻量的 **mbedTLS**

这些库提供了完整的加解密、证书认证和密钥协商接口。

------


### 2️⃣ 建立 SSL/TLS 上的安全连接

原本服务器是直接用 `socket` + `epoll` 监听 TCP 连接，如果要支持 HTTPS：

- 在客户端连接建立后，通过 `SSL_accept()` 与客户端完成 TLS 握手，协商密钥。
- 握手成功后，双方通信基于对称加密，确保数据在传输过程中的安全性。

------

### 3️⃣ 改造 I/O 读写接口

HTTP 明文是通过 `read` / `write` 来读写 socket 的。
 而 HTTPS 中：

- 读操作用 `SSL_read()`
- 写操作用 `SSL_write()`
- 握手阶段用 `SSL_accept()`

这几个 OpenSSL API 底层会完成解密、加密和数据包封装。

------

### 4️⃣ 配置服务器证书和密钥

服务器需要配置：

- **服务器私钥**
- **服务器证书**
- （可选）**CA 根证书**

这些在初始化 SSL 上下文时用 `SSL_CTX_use_certificate_file()` 和 `SSL_CTX_use_PrivateKey_file()` 加载。

------


### 5️⃣ 调整 epoll 的事件驱动逻辑

因为 `SSL_read()` 和 `SSL_write()` 本质上是对 socket 的包装，但存在 SSL 层缓冲区：

- 需要在 epoll 可读/可写事件到来时，再调用对应的 SSL 接口。
- 还要处理 `SSL_ERROR_WANT_READ` 和 `SSL_ERROR_WANT_WRITE` 这种非阻塞情况下的中间状态。

如果要加 WebSocket 功能，怎么改架构？

# 线程池

## 为什么使用线程池？

## 多线程模式怎么设计的？是主从 Reactor、线程池、one loop per thread 还是别的？

## 线程池是自己写的吗？线程池里线程怎么管理，空闲线程如何回收？

## 线程池中的线程数量如何确定？

## 单个 worker 线程阻塞了，其他线程怎么感知？

## 当线程池已满，还有新的任务到来时，你是如何处理的？

## 线程池工作线程处理完一个任务后的状态是什么？

## 如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？

## 如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?

# 定时器

## 为什么用小根堆？

## 其他定时器的实现？差异？

# 日志系统

## 如何实现的？怎么实现同步的？怎么实现异步的？

在我的 C++ WebServer 项目中，日志系统采用**单例模式**实现，核心功能包括日志的初始化配置、日志等级控制、日志文件管理以及同步/异步两种写入模式。

### 📌 同步日志实现方式：

**同步日志**的思路是：**业务线程在写日志时，直接将日志信息写入磁盘文件**，写完之后再继续后续业务逻辑。

- 日志内容会先格式化好，拼接时间、等级等基本信息。
- 然后直接写入日志文件，并及时刷新，确保日志内容落盘。

**特点**：

- 实现简单，日志实时性和安全性好，不易丢失。
- 缺点是高并发场景下会导致业务线程频繁阻塞，影响服务器整体吞吐性能。

**适合**：

- 小型服务、异常日志、启动日志等对实时性要求较高的场景。

------

### 📌 异步日志实现方式：

**异步日志**是通过**阻塞队列和后台日志线程的方式**来提高写日志的性能。

- 业务线程在写日志时，不直接写磁盘，而是将日志信息放入内存队列中，立即返回，继续执行业务逻辑。
- 后台有一个独立的写日志线程，不断从队列中取出日志内容，统一批量写入磁盘文件。
- 系统还设有唤醒机制，定时或在日志积压较多时唤醒后台线程及时刷盘。

**特点**：

- 能有效避免主线程阻塞，适合高并发、高频日志场景。
- 极端情况下存在日志在内存队列中未刷盘而丢失的风险，但可通过定时刷新、关闭前强制刷盘等机制降低风险。

**适合**：

- 高并发 WebServer、业务日志量较大的场景。

## 日志系统的缓冲区满了（内存不足）怎么办？

在我的 C++ WebServer 项目中，日志系统采用的是**异步日志记录机制**，主线程将日志写入内存缓冲区，后台线程异步刷盘，减少主线程 I/O 阻塞。

如果日志缓冲区满了或者内存不足，常见的应对方式有以下几种：

------

### 1️⃣ 阻塞等待（简单型方案）

当缓冲区满了，主线程**阻塞等待**后台日志线程将部分缓冲区内容写入磁盘，再继续写入新日志。

- 优点：实现简单，保证所有日志写入。
- 缺点：高并发下可能阻塞主线程，影响服务器响应。

------

### 2️⃣ 丢弃部分低优先级日志（高可用方案）

为了保证服务器稳定性，可以选择**丢弃部分非关键日志**，只保留 ERROR、WARN 级别的重要日志：

- 缓冲区满时，根据日志等级筛选，优先保留高优先级日志，丢弃 DEBUG、INFO。

------

### 3️⃣ 增加临时应急缓冲区（优化型方案）

当主缓冲区满时，临时申请一个**备用缓冲区**（spare buffer），继续写入日志，避免阻塞。

- 日志线程优先将主缓冲区写盘，腾出空间，再处理备用缓冲区。

------

### 4️⃣ 后台线程加速刷盘

缓冲区快满时，**立即唤醒日志线程**，优先将内存中的日志写入磁盘，缓解内存压力。
 可以通过条件变量或信号量机制实现。

------

### 📌 我的实现：

我项目里的异步日志系统采用了**双缓冲机制**：

- 一个**当前缓冲区**（current buffer）
- 一个**备用缓冲区**（next buffer）

主线程写满 current buffer 后，立即切换到 next buffer，日志线程负责将旧缓冲区写入磁盘。
 如果两块缓冲区都满了，会：

- 丢弃部分低优先级日志，或者
- 阻塞等待日志线程刷盘

保证在高并发日志写入下，服务器依然稳定运行。

## 日志文件怎么切割？支持按天/按大小切割吗？

在我的 C++ WebServer 项目里，日志文件的切割是通过**日志系统中的后台线程定时检查机制**实现的，支持以下两种常见切割方式：

------

### 1️⃣ 按天切割（Time-based Rolling）

日志线程每次写入日志前，都会检查当前日期：

- 如果日期变化了（比如从 `2025-05-06` 变到 `2025-05-07`），就**关闭当前日志文件**，重新创建一个以新日期命名的日志文件，例如：

```
lua复制编辑server_log_2025-05-06.log  
server_log_2025-05-07.log
```

- 同时保证日志线程写入到新的日志文件里。

**优点**：方便日志归档和按天检索，常用于运维场景。

------

### 2️⃣ 按大小切割（Size-based Rolling）

在日志线程写入日志前，判断当前文件大小：

- 如果超过预设阈值（例如 100MB），就将当前文件重命名：

```
lua复制编辑server_log.log → server_log.log.1
server_log.log.1 → server_log.log.2
```

- 然后新建一个新的 `server_log.log` 继续写入。

**优点**：防止单个日志文件过大导致查看困难、磁盘 I/O 效率降低。

------

### 📊 如何实现：

**方法**：

- 每次日志线程写入前，记录当前文件大小、当前日期
- 定时（或每次写入）检查是否到达切割条件：
  - `if (nowDate != lastLogDate)`
  - `if (fileSize >= maxSize)`

**切割流程**：

1. 关闭当前日志文件
2. 重命名原日志文件（带日期或序号）
3. 新建日志文件，更新文件描述符和文件名
4. 继续写入日志

## 服务器挂了，日志也没打印，怎么排查问题？

如果服务器挂了，日志也没有打印出来，我会从以下几个维度来排查问题：

### 1️⃣ **确认进程状态**

- 首先用 `ps -ef | grep server` 或 `top` 查看进程是否存在。
- 如果进程不在，确认是异常崩溃（core dump）、主动退出还是被系统 kill。

------

### 2️⃣ **查看系统日志**

- 查看 `/var/log/messages`、`/var/log/syslog`、`/var/log/kern.log` 看是否有内核或 OOM Killer 记录：

```
dmesg | grep -i kill
```

常见情况：

- OOM 被系统杀掉
- 段错误 (Segfault)
- 资源占满导致挂掉

------

### 3️⃣ **检查 core dump**

- 确认 core dump 是否开启：

```
ulimit -c
```

如果开启，检查 core 文件（`core.xxxx`），用 `gdb` 调试：

```
gdb ./webserver core.xxxx
bt  // 查看栈回溯，定位崩溃点
```

------

### 4️⃣ **排查日志系统本身问题**

既然日志也没打出来，可能日志系统出问题：

- 查看日志线程是否存活
- 检查日志缓冲区是否阻塞满了，或者死锁
- 确认日志文件权限、磁盘空间、是否满盘：

```
df -h
```

------

### 5️⃣ **排查网络/端口冲突**

- 查看 `netstat -tulnp` 是否端口被其他进程占用，导致 bind 失败挂掉。
- 或者高并发下 `epoll` I/O 队列耗尽（可以看 `/proc/sys/fs/epoll/max_user_watches`）

------

### 6️⃣ **查看部署和依赖环境**

- 数据库、缓存服务是否正常
- 配置文件路径是否正确
- 检查最近是否有版本更新或热部署操作

# 数据库

## 为什么要使用 MySQL 连接池？

### ✅ 1️⃣ 数据库连接开销大

- 每次创建、释放数据库连接都会涉及**TCP 三次握手/四次挥手、权限认证、资源申请**，耗时明显（一般几毫秒到几十毫秒）
- 高并发场景下，频繁建立连接会极大影响系统吞吐和响应性能

------

### ✅ 2️⃣ 限制最大连接数，保护数据库

- 数据库服务器自身有 `max_connections` 限制
- 没有限制地开新连接会拖垮数据库，导致服务雪崩

------

### ✅ 3️⃣ 连接复用，提升并发处理能力

- 通过复用已有空闲连接，**避免重复建连销毁**
- 保证数据库操作的高效、低延迟

------

### ✅ 4️⃣ 集中管理，统一状态检测

- 统一检测连接是否可用、超时、异常
- 保证池内连接健康，提升系统稳定性

## 连接池是如何实现的？

### ✅ 核心结构：

一般由以下几个部分组成：

- **连接队列（list/queue/vector）**：存放可用数据库连接
- **线程安全机制**：多线程环境下通过 `mutex + condition_variable` 或无锁队列保护连接队列操作
- **最大连接数、空闲数、超时配置**
- **定时器**：定期检查连接健康状态和空闲超时

------

### ✅ 实现流程：

1. **初始化阶段**：
   - 启动时预先创建固定数量连接放入池中
2. **取连接（GetConnection）**：
   - 多线程竞争时，使用 `mutex` 加锁，或 `condition_variable` 阻塞等待可用连接
   - 取出连接，放给业务线程使用
3. **归还连接（ReleaseConnection）**：
   - 业务操作完成后，将连接归还池中，供其他线程复用
4. **异常和超时处理**：
   - 每次取用时，先 `ping` 检测连接是否可用
   - 定期销毁超时或异常连接，补充新连接维持池子满员

## 用户登录功能中，如何防止SQL注入？

### 什么是 SQL 注入？

SQL 注入是指恶意用户通过构造特殊的 SQL 字符串，把非法 SQL 语句拼接到程序的查询语句中，最终改变原本的执行逻辑，达到**非法登录、窃取、篡改数据库数据**的目的。

----

在 C++ WebServer 项目中，我主要通过**预处理语句（PreparedStatement）+ 参数绑定**的方法来防御。

### ✅ 实现方式：

- **使用 MySQL C API 提供的 `mysql_stmt_prepare()`、`mysql_stmt_bind_param()`、`mysql_stmt_execute()` 系列接口**
- **把用户输入的内容作为参数绑定，避免字符串拼接**

### 📌 原理：

- **预处理阶段**：先把 SQL 语句发送到数据库服务器进行语法检查、预编译，SQL 字符串中的 `?` 位置是占位符，不会执行。
- **执行阶段**：把用户输入的数据单独传递给数据库，作为参数绑定到占位符上，数据部分与 SQL 语义隔离，数据库只把它当普通字符串处理，不能改变原 SQL 结构。

## 如何防止恶意用户进行暴力破解密码的行为？

暴力破解是指攻击者通过程序**频繁尝试不同密码组合**，直至猜中合法账户密码。为了防止这类攻击，我的 WebServer 项目主要采取了以下几种防护手段：

------

### ✅ 1. **限制登录失败次数**

- **思路**：给每个账户或 IP 地址记录连续失败次数，超出阈值（比如 5 次）后，限制其登录操作一段时间。
- **实现方法**：
  - 可以在服务器内存或 Redis 中维护 `ip/username -> 失败次数+最后尝试时间`
  - 超过阈值，暂时冻结账户或拒绝该 IP 登录请求

------

### ✅ 2. **引入验证码机制**

- **思路**：在用户连续登录失败后，或者登录页面默认加入验证码（滑动验证码/图片验证码/短信验证码）
- **作用**：阻止自动化脚本的批量尝试，增加破解门槛

------

### ✅ 3. **加密存储密码**

- **思路**：即便暴力破解成功，也避免用户密码泄露
- **实现方法**：
  - 密码使用强哈希算法（如 bcrypt、PBKDF2、Argon2）
  - 加盐（salt）后再哈希，防御彩虹表攻击
  - 每个用户随机 salt，存入数据库

------

### ✅ 4. **延迟响应（随机延时）**

- **思路**：检测到连续失败时，对登录请求延迟响应，降低暴力破解效率
- **实现方法**：
  - 每次失败延迟 500ms～2s，几千次尝试会显著耗时

------

### ✅ 5. **IP 黑名单/限流**

- **思路**：
  - 针对异常请求频率的 IP，加入黑名单
  - 或通过令牌桶、漏桶算法限制单位时间内同一 IP 请求次数
- **效果**：防止单 IP 高频请求，保障服务器稳定

------

### ✅ 6. **HTTPS 加密传输**

- 防止登录过程中被中间人嗅探明文用户名和密码，保护数据传输安全。

## 连接池中的连接如何进行状态管理，比如如何判断一个连接是否可用，如何处理连接超时等情况？

为了保证连接池内连接的可用性与健康性，我在项目实现中，通常通过以下手段管理连接状态：

------

### ✅ 1. **连接可用性判断**

每次从连接池中取连接或使用连接前，都会检查该连接是否仍然可用。常见方法：

- **ping 心跳检测**：调用 `mysql_ping()`（MySQL C API）测试连接是否断开，如果断开自动重连或丢弃。
- **执行轻量 SQL**：例如 `select 1` 或 `select now()` 检查连接是否正常响应。

👉 这通常发生在：

- 取连接出池时
- 使用连接执行 SQL 前

------

### ✅ 2. **连接超时管理**

为了避免连接长时间闲置被数据库服务器主动断开，或者连接因网络原因异常，项目里常用：

- **空闲超时策略**：
  - 每个连接记录最近一次使用时间。
  - 定期（或取出前）检查连接空闲时间是否超过设定阈值（比如 300s）
  - 超时的连接释放或重建，防止“死连接”。
- **定时器轮询检测**：
  - 利用 `HeapTimer` 或后台线程定期扫描池内空闲连接。
  - 超时的直接销毁，或者执行 `ping` 保持活跃。

------

### ✅ 3. **异常连接的处理**

执行 SQL 时，若发现连接异常（如 `mysql_real_query` 返回错误码 2006: MySQL server has gone away）：

- 立即关闭并从连接池移除该连接。
- 若当前连接池数量未达上限，重新新建一个连接放回池中，保持池子满员。

## 在高并发场景下，连接池如何保证数据库操作的性能和稳定性？

### ✅ 1️⃣ 限制最大连接数，避免数据库超载

- **设定合理的最大连接数 MaxConn**
- 防止瞬间高并发直接打爆数据库（MySQL 本身也有最大连接数限制）
- 当连接用尽，采用阻塞或超时返回策略，**避免雪崩效应**

------

### ✅ 2️⃣ 使用线程安全队列管理连接

- 多线程环境下，通过 `std::mutex + condition_variable` 或无锁队列管理连接池
- 保证并发取用、释放连接的**原子性与一致性**
- 防止竞争、死锁、连接泄漏等问题

------

### ✅ 3️⃣ 复用连接，降低连接创建销毁开销

- 连接池在服务启动时，**预先建立一定数量连接**
- 每次数据库操作复用现有连接，避免频繁 `connect`/`disconnect`
- 提高吞吐量，降低系统平均响应时间

------

### ✅ 4️⃣ 实时检测、剔除异常连接

- 每次取用或执行 SQL 前，通过 `mysql_ping()` 检查连接是否有效
- 发现异常，**立即销毁并补充新连接**
- 保证池内连接永远可用，防止高并发场景下出现“死连接”

------

### ✅ 5️⃣ 超时管理，避免长时间占用连接

- 每个连接记录**最后使用时间**
- 超过设定空闲阈值，**定期销毁或重建**
- 防止连接池中堆积大量空闲连接，或被数据库主动断开导致意外

------

### ✅ 6️⃣ RAII 封装，自动回收连接

- 项目中用 `SqlConnRAII` 类封装数据库连接
- **作用域结束自动释放归还连接**
- 防止线程在异常或中途退出导致连接泄露，提高系统稳定性

------

### ✅ 7️⃣ 预警+监控机制（可选）

- 监控池内空闲连接数、活跃连接数、超时时间
- 高并发临界点，提前扩容或限流，保障系统稳定

# 压力测试

## 你在项目中是如何进行单元测试的？使用了哪些单元测试框架？

### 1. **单元测试框架的选择**

我选择 Google Test 主要是因为它具有以下优势：

- **简洁易用**：Google Test 提供了简单且直观的接口，使得编写测试变得更加高效。
- **丰富的断言支持**：Google Test 提供了多种断言类型（如 `EXPECT_EQ`、`EXPECT_TRUE`、`EXPECT_FALSE` 等），帮助验证代码的行为和状态。
- **支持测试夹具（Fixture）**：通过测试夹具，我可以为多个测试用例提供共享的测试环境和清理工作，避免重复代码，提升测试的效率。
- **良好的集成支持**：Google Test 与 CMake 集成顺畅，能够方便地与持续集成工具（如 Jenkins）结合，自动化执行单元测试。

### 2. **单元测试的实施**

在这个项目中，我对每个功能模块进行了单元测试。具体来说：

- **Buffer**：测试缓冲区的内存管理、数据存储和增长策略。
- **Log**：测试同步和异步日志的写入正确性，确保日志模块高效且无阻塞。
- **SqlConnectPool**：测试数据库连接池的连接管理，验证连接的获取、释放以及复用。
- **HttpRequest 和 HttpResponse**：测试 HTTP 请求的解析和响应报文的生成，确保请求和响应符合规范。
- **HeapTimer**：测试定时器是否按时触发任务，确保超时处理和定时任务的执行。

### 3. **如何运行测试**

所有测试代码都放在 `test` 目录下，并通过 **CMake** 构建系统进行管理。使用 `make` 命令编译测试程序，运行测试时会自动执行所有的单元测试，并显示测试结果。

## Webbench 测压原理？

**Webbench** 是一个轻量级的 Web 压力测试工具，能够模拟多客户端并发访问服务器，测量服务器在单位时间内能处理的请求数。

------

### ✅ 工作原理：

1️⃣ **父子进程模型**

- Webbench 启动时，**父进程 fork 出多个子进程**
- 每个子进程充当一个客户端，独立发起 HTTP 请求

------

2️⃣ **每个子进程发起循环请求**

- 每个子进程创建 socket，连接到目标服务器，发送固定格式 HTTP 请求
- 每次请求后统计成功次数，持续到测试时间耗尽
- 多进程实现并发压力模拟

------

3️⃣ **进程间通过管道通信**

- 每个子进程将自身请求次数、失败次数通过 **管道（pipe）** 汇报给父进程
- 测试结束后，父进程汇总所有子进程的请求统计，计算总的：
  - Requests per second（QPS）
  - 吞吐量
  - 成功率等指标

------

4️⃣ **不接收响应内容，仅统计响应次数**

- Webbench **只发送请求，不解析响应正文**，只看是否接收到响应，统计成功与否，保证压测足够轻量高效

## 除了 Webbench，还考虑过使用其他压力测试工具吗？

### ✅ 1️⃣ **wrk** （推荐🔥）

- **特点**：高性能 HTTP 压测工具，基于多线程 + epoll/kqueue + Lua 脚本扩展
- **优点**：
  - 支持多线程压测，能充分利用多核 CPU
  - 支持自定义 HTTP 请求、Header、延迟、连接数等
  - 输出指标详细（QPS、延迟分布、最大最小响应时间）
- **适用场景**：现代高并发 HTTP 服务性能测试
- **我实际用过**，比 Webbench 性能高，功能全

------

### ✅ 2️⃣ **ab（Apache Benchmark）**

- **特点**：Apache 官方自带 HTTP 压测工具
- **优点**：
  - 简单易用，单命令即可执行压测
  - 输出响应时间、成功率、QPS、并发数等基础指标
- **缺点**：
  - 单线程，不能充分压榨多核 CPU 性能
- **适用场景**：中小型项目、API 接口单点压测

------

### ✅ 3️⃣ **siege**

- **特点**：支持 HTTP 并发访问、支持配置用户请求脚本
- **优点**：
  - 支持 GET/POST 测试
  - 支持模拟多用户负载
  - 响应时间统计详细
- **适用场景**：多用户并发访问模拟、接口稳定性测试

------

### ✅ 4️⃣ **Go 自研压测脚本（如果用 Go 重写项目）**

- Go 有成熟的 net/http 库，**结合 goroutine + channel** 很容易实现高并发 HTTP 请求压测工具
- 优点：灵活、轻量、定制化强
- 适用场景：专门压测 WebServer、HTTP 长连接或 WebSocket 服务

------

### 📌 为什么最终选用 Webbench 做基础压测？

- Webbench 非常**轻量、上手快**
- 没有复杂配置，适合做**基础 QPS 性能对比**
- 多进程模式，和我 C++ WebServer 多线程/epoll 模型相近，便于快速验证并发性能

不过在后期优化和高并发性能极限测试时，我用 **wrk** 替代 Webbench，压测更细致，结果更全面。

## 你的服务器单机能支撑多少并发？压力测试过吗？瓶颈在哪？

### 📌 我的服务器单机能支撑多少并发？

在我做的这套 **C++ WebServer 项目**里，使用 **Epoll + 线程池 + Reactor 模型**，我用 Webbench 和 wrk 做过多轮压测：

- **单核** 环境下：
   👉 稳定支撑 **4K~5K 并发连接**，QPS 约 **20K/s**
- **四核八线程服务器**环境（无磁盘 IO 限制，内存充足）：
   👉 稳定支撑 **2W~3W 并发连接**，QPS 约 **7W~8W/s**

------

### 📌 实际压力测试情况

我做过多轮压测验证：

- 模拟**持续高并发 HTTP 请求**
- 模拟**大量慢请求**测试长连接占用情况
- 模拟**瞬时连接洪峰**测试反应速度

主要测试指标包括：

- QPS（请求数/秒）
- 延迟（平均响应时间、最大响应时间）
- 成功率、失败率
- CPU、内存、线程池负载、epoll 活跃连接数

------

### 📌 瓶颈在哪？

### ✅ 1️⃣ 磁盘 IO （瓶颈最高）

- HTTP 请求资源是文件时，频繁 `open + mmap` 或 `sendfile`，磁盘 IO 容易阻塞，导致响应延迟增大
- **优化措施**：
  - 启用 `sendfile` 零拷贝
  - 热资源内存缓存
  - 减少磁盘访问次数

------

### ✅ 2️⃣ 线程池调度开销

- 高并发下，线程池任务队列阻塞、线程切换、竞争锁，带来 CPU 抢占和上下文切换开销
- **优化措施**：
  - 合理调整线程池线程数
  - 采用无锁队列、事件驱动机制

------

### ✅ 3️⃣ 网络栈参数限制

- Linux 默认 `backlog`、`somaxconn`、`ulimit` 太小，限制大量连接建立
- **优化措施**：
  - 调整 `net.core.somaxconn`、`net.ipv4.tcp_max_syn_backlog`、`ulimit -n`
  - 调大 epoll 最大监听数

------

### ✅ 4️⃣ Reactor 单线程瓶颈

- 虽然多线程处理，但 Epoll 事件监听是单线程，极限高并发下监听线程压力较大
- **优化措施**：
  - 拆分监听和读写处理
  - 或者用多 Reactor + 负载均衡方案

# 综合能力

## 你的项目解决了哪些其他同类项目没有解决的问题？

### 1️⃣ **高效的内存缓冲区设计**

- **问题**：许多 Web 服务器在处理请求和响应时频繁进行系统调用，可能导致性能瓶颈，特别是在高并发场景下。
- **解决方案**：我们设计了一个高效的 **Buffer** 类，使用 `std::vector<char>` 存储数据，避免了频繁的内存分配和释放。该缓冲区能够在需要时自动增长，从而减少了系统调用次数，提高了数据处理的效率。这使得我们的 Web 服务器在高并发环境下能够更高效地处理大量请求。

### 2️⃣ **日志模块的同步与异步处理**

- **问题**：在高并发系统中，日志操作会成为瓶颈。传统的 Web 服务器可能在日志记录时阻塞主线程，影响处理速度。
- **解决方案**：我们设计了一个日志模块，通过 **单例模式** 管理日志实例，支持 **同步和异步** 日志写入。同步日志可以直接写入文件，而异步日志则通过 **阻塞队列** 提交到一个独立的日志线程中进行处理。这种设计使得 Web 服务器能够在不影响性能的情况下，保证日志记录的准确性和完整性。

### 3️⃣ **数据库连接池的高效管理**

- **问题**：每次建立和关闭数据库连接的开销很大，这在数据库频繁访问的场景下尤为明显。传统的 Web 服务器可能没有一个高效的数据库连接管理方案。
- **解决方案**：我们利用 **RAII**（Resource Acquisition Is Initialization）机制实现了一个数据库连接池，减少了数据库连接的创建和销毁开销。连接池中的连接在请求之间被复用，大大提高了数据库访问的效率。

### 4️⃣ **HTTP 请求解析的高效设计**

- **问题**：传统的 Web 服务器在解析 HTTP 请求时，可能会面临较为复杂和低效的处理流程，特别是当请求内容较大时，可能会导致性能问题。
- **解决方案**：我们使用了 **状态机** 和 **正则表达式** 来解析 HTTP 请求，并且集成了数据库访问来支持 Web 端用户注册和登录功能。状态机使得 HTTP 请求解析变得更加高效，正则表达式则帮助快速匹配 URL 和参数，使得请求处理过程更加灵活且高效。

### 5️⃣ **定时器的高效管理**

- **问题**：在高并发的 Web 服务器中，需要定期处理超时连接和定时任务。如果使用简单的定时器管理机制，可能导致性能下降。
- **解决方案**：我们使用 **小根堆** 实现了定时器管理，这样可以保证定时任务的优先级顺序，使得任务调度更加高效。当连接超时或需要执行定时任务时，Web 服务器能够迅速响应，避免了不必要的延迟。

### 6️⃣ **Epoll 和线程池的结合**

- **问题**：传统的 Web 服务器可能采用单线程或单一的 IO 复用模型，无法充分利用多核 CPU 的性能，导致吞吐量低、响应时间长。
- **解决方案**：我们通过 **Epoll** 技术实现了 **IO 复用**，并结合 **线程池** 模型，实现了 **Reactor 模式**。在这个模型下，服务器能够高效地处理大量并发请求，多个工作线程处理不同的连接，极大提高了 Web 服务器的吞吐量和响应速度。

### 7️⃣ **文件映射的响应优化**

- **问题**：对于静态文件的响应，传统的 Web 服务器可能采用读取文件到内存的方式，随着文件大小的增加，内存开销和文件读取性能都会受到影响。
- **解决方案**：我们在 **HttpResponse** 类中实现了 **文件映射**（memory-mapped files）机制，将文件映射到内存中，从而提高了文件读取的速度。文件映射可以避免大文件读取时的额外内存复制，提高了对静态文件响应的性能。

### 8️⃣ **线程安全和高并发支持**

- **问题**：在多线程环境下，如何保证线程安全，同时避免锁竞争和性能瓶颈，是 Web 服务器设计中的一个挑战。
- **解决方案**：通过使用 **线程池** 和 **无锁队列**，我们有效地提高了并发性能，同时保证了线程安全。通过合理的线程池大小控制和任务分配，避免了过度创建线程和线程竞争带来的性能下降。

## 项目中有没有使用到设计模式？

### ✅ **1. 单例模式（Singleton）——用于日志系统 Log**

- **用法：** 日志类全局只创建一个实例，避免多个线程输出日志时竞争资源。

- **目的：** 保证日志文件统一管理，避免多实例导致的混乱输出。

- **面试说法：**

  > “日志模块使用了**单例模式**，确保全局只有一个日志对象，同时避免了多线程下的资源竞争问题。”

------

### ✅ **2. 生产者-消费者模式（Producer-Consumer）——日志系统的异步写入**

- **用法：** 主线程将日志写入阻塞队列作为生产者，后台线程从队列中读取并写入文件作为消费者。

- **目的：** 降低主线程阻塞，提高日志处理性能。

- **面试说法：**

  > “在异步日志中，利用阻塞队列实现了生产者-消费者模型，异步线程后台写日志，避免主线程阻塞。”

------

### ✅ **3. RAII（Resource Acquisition Is Initialization）——数据库连接池**

- **用法：** 封装数据库连接对象，构造时获取连接，析构时自动释放。

- **目的：** 管理资源生命周期，避免手动释放导致的泄漏。

- **面试说法：**

  > “数据库连接池使用了 RAII 机制，将连接封装在栈对象中，在作用域结束时自动释放，避免连接泄露。”

------

### ✅ **4. 状态机模式（State Machine）——HttpRequest 解析流程**

- **用法：** 拆分 HTTP 请求的解析流程：请求行 -> 请求头 -> 请求体，每一步是一个状态，转换明确。

- **目的：** 使解析逻辑清晰、可维护，适应不完整或分段到来的数据。

- **面试说法：**

  > “在请求解析中，我引入了状态机模式，将解析流程拆分为不同状态，提升了解析的健壮性与可读性。”

## 如果服务器在运行的过程中，实际存储的文件被其他用户修改了，会发生什么？

### 1️⃣ **文件内容被修改：**

如果客户端请求的资源（如 HTML 文件、图片等）在服务器运行时被其他用户修改，WebServer 可能会遇到以下情况：

#### **情况：** 文件内容发生变化，但文件描述符仍然指向原文件。

- **现象**：WebServer 可能会继续将文件的旧内容返回给客户端，直到文件被重新打开。因为操作系统会缓存文件的描述符，并且文件的映射内容已经加载到内存中。如果文件内容发生变化，WebServer 必须重新读取该文件才能得到最新的内容。
- **原因**：文件操作系统通常会对文件句柄进行缓存，并且当文件被打开时，WebServer 会将文件内容加载到内存中，之后会直接使用内存中的内容，而不去重新读取文件，除非文件句柄被关闭并重新打开。

#### **解决方案：**

- **文件缓存失效**：为了确保 WebServer 获取到最新的文件内容，可以通过以下方式来避免缓存问题：
  - **文件监控**：使用文件监控机制（如 inotify 在 Linux 上）来检测文件是否发生变化。如果文件发生变化，可以强制重新加载文件。
  - **定期检查文件修改时间**：每次请求文件时，可以通过检查文件的 `mtime`（修改时间）属性，来判断文件是否已经被修改。如果文件已经被修改，重新加载文件。

------

### 2️⃣ **文件被删除或移动：**

#### **情况：** 文件在 WebServer 服务运行时被删除或移动。

- **现象**：如果 WebServer 正在处理一个请求，并且在响应过程中该文件被删除或移动到其他位置，WebServer 可能会返回错误（如 404 或 410 错误），或者可能导致文件访问失败。
- **原因**：操作系统文件删除或移动操作会影响文件的访问。如果文件被删除，WebServer 会发现文件句柄失效，进而触发错误。

#### **解决方案：**

- **错误处理**：WebServer 在访问文件时，应当加入合适的错误处理机制。当文件被删除或移动时，可以及时返回 404（文件未找到）或 410（文件已被移除）响应。
- **文件锁定**：为了避免多个进程或线程在文件修改时同时进行读取，可以使用文件锁定机制来保证只有一个进程在任何时候访问文件。对于文件的删除、移动操作，应该考虑如何与其他进程的操作进行协调。

------

### 3️⃣ **文件被替换：**

#### **情况：** 文件被替换为不同的内容。

- **现象**：如果文件在服务器运行过程中被其他用户修改为不同的内容，WebServer 可能会返回新的文件内容。具体返回的内容取决于文件修改的时机和 WebServer 的文件缓存机制。如果文件已经被读取到内存中并没有重新加载，服务器可能继续返回旧内容，直到重新读取该文件。
- **原因**：文件被替换时，文件系统会更新文件内容，但是 WebServer 不一定会立刻检测到文件的变化，除非它重新打开文件或检查文件的修改时间。

#### **解决方案：**

- **缓存失效机制**：可以通过文件的修改时间（`mtime`）来检测文件是否被替换。如果文件被替换，强制让 WebServer 重新加载文件并更新缓存内容。
- **版本控制和文件锁定**：可以为文件操作添加版本控制，每次文件被修改时生成新的文件版本，以便 WebServer 可以检测并使用新版本的文件。另外，使用文件锁定机制也可以避免文件在修改时被同时读取。

------

### 4️⃣ **并发访问和文件修改的竞争条件：**

#### **情况：** 多个客户端同时请求相同的文件，并且文件在此过程中被其他用户修改。

- **现象**：可能会导致请求之间的竞争条件，甚至发生数据不一致的情况。例如，一个客户端在读取文件的过程中，文件内容被修改，而另一个客户端在文件修改后读取到不同的内容。
- **原因**：并发访问文件时，如果没有适当的同步机制，会导致文件内容在不同请求之间不一致。

#### **解决方案：**

- **加锁机制**：可以在文件的读取和写入操作上加锁，确保在文件被读取时其他用户无法修改文件，避免并发访问导致的不一致性问题。
- **悲观锁与乐观锁**：对于需要高并发读取的场景，可以考虑使用**乐观锁**（如文件版本号）来避免锁的开销。而对于需要确保一致性的场景，可以使用**悲观锁**。

## 如果让你用Go重写这个项目，你会保留哪些设计？为什么?

### 1️⃣ **Reactor 模型和 IO 复用**

#### 保留设计：

- **Reactor 模型**：我会继续采用 **Reactor 模型**，因为它在高并发情况下非常高效。Go 本身的 **goroutine** 和 **channel** 实现了类似的事件驱动和协作式多任务调度机制，所以通过 Reactor 模型来调度和处理高并发的网络请求是非常合适的。
- **IO 复用（Epoll、select 等）**：虽然 Go 自带的 `net/http` 包和 **goroutine** 本身就具有高并发处理能力，但在需要高性能时，仍然可以利用 **IO 复用** 来手动控制事件监听和工作线程的分配，增强灵活性与性能。

#### 为什么保留：

- **Reactor 模型** 是处理高并发的经典模式，采用 epoll 或其他 IO 复用技术，能够在少量线程的情况下处理大量的连接。
- Go 内建的并发和调度机制是基于 **goroutine** 和 **channel** 的，但当涉及更底层的事件驱动机制时，Reactor 依然能够提供更高效的控制。

------

### 2️⃣ **缓冲区设计（Buffer）**

#### 保留设计：

- **动态缓冲区（Buffer）**：在 Go 中，虽然可以直接使用 `[]byte` 来存储数据，但是类似 C++ 中的 `vector<char>` 缓冲区设计可以帮助我们避免频繁的内存分配和拷贝。因此，**自增长的缓冲区** 仍然是个不错的选择。可以通过 `sync.Pool` 来优化内存管理，减少垃圾回收的压力。

#### 为什么保留：

- **内存高效**：通过自增长的缓冲区，可以灵活地应对不同大小的请求和响应数据，避免了每次请求都重新分配内存带来的性能损耗。
- **与 Go 的内存管理兼容**：Go 的垃圾回收机制可能在一些场景下导致性能下降，使用 `sync.Pool` 和自增长的缓冲区可以更好地控制内存管理，减少内存分配次数。

------

### 3️⃣ **异步日志（Log）**

#### 保留设计：

- **异步日志系统**：我会继续采用 **异步日志** 设计，日志操作不会阻塞主线程或请求处理线程。可以使用 **Go 的 channel** 来实现日志的异步写入，使用 `sync.Mutex` 或 `sync.Once` 来保证线程安全。

#### 为什么保留：

- **性能优化**：日志写入是 I/O 操作，可能会造成阻塞，影响主线程性能。异步写日志可以确保日志写入操作不会影响请求处理的性能，尤其是对于高并发的系统。
- **Go 内置的并发特性**：Go 自带的 `goroutine` 和 `channel` 使得异步处理变得非常简单且高效。

------

### 4️⃣ **数据库连接池（SqlConnectPool）**

#### 保留设计：

- **数据库连接池**：在 Go 中，我们可以利用 `database/sql` 包和第三方库（如 `github.com/jmoiron/sqlx`）来实现数据库连接池。通过 **RAII 机制** 实现连接池的管理，并确保数据库连接的高效复用。

#### 为什么保留：

- **减少数据库开销**：数据库连接的创建和销毁开销较大，采用连接池可以有效减少这些开销，提高数据库访问性能。
- **Go 支持连接池**：Go 原生支持数据库连接池，并且提供了非常好的并发控制机制，使得连接池在高并发场景下可以高效工作。

------

### 5️⃣ **定时器管理（HeapTimer）**

#### 保留设计：

- **HeapTimer**：Go 本身的 `time.Timer` 和 `time.Ticker` 可以实现简单的定时任务管理，但为了高效的定时任务调度和连接超时管理，我会保留 **基于小根堆实现的定时器管理** 设计，优化定时任务的执行。

#### 为什么保留：

- **定时任务调度**：通过堆数据结构进行定时任务管理，可以确保任务按照时间顺序执行，并且优化超时连接的处理。
- **灵活性和高效性**：在 Go 中，虽然定时器已经有内建的支持，但如果有特定的性能要求，使用堆管理定时任务可以提高效率。

------

### 6️⃣ **HttpRequest 和 HttpResponse 解析**

#### 保留设计：

- **状态机解析 HTTP 请求**：Go 本身通过 `net/http` 已经能处理大部分 HTTP 请求，但为了提高性能，我会保留 **状态机解析 HTTP 请求** 的设计，尤其是在对 HTTP 请求进行定制化解析时。可以通过 Go 的 `regexp` 包来处理请求路径和参数解析。
- **文件映射（HttpResponse）**：文件映射对于静态资源的响应非常重要，因此我们会继续采用文件映射来提高静态文件访问的速度。

#### 为什么保留：

- **高效的请求处理**：通过状态机的设计，能够确保请求的高效解析和处理，避免了不必要的多次扫描。
- **文件映射优化性能**：通过映射文件到内存，提高了静态资源的访问速度，避免了频繁的磁盘 IO。