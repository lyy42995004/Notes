# Hello, World

**Hello world**

```go
package main
import "fmt"
func main() {
    fmt.Println("Hello, 世界")
}
```

`package main`表明这是一个可独立执行的程序包；`import "fmt"`导入标准库中的`fmt`包，用于格式化输入输出 ；`main`函数是程序的入口，`fmt.Println`函数输出 “Hello, 世界”。

**程序运行**

- **`go run`命令**：`$ go run helloworld.go`可直接编译、链接并运行`.go`源文件，输出 “Hello, 世界” 。
- **`go build`命令**：`$ go build helloworld.go`将生成名为`helloworld`的二进制程序，之后执行`$./helloworld`也能输出 “Hello, 世界” ，适用于创建可复用程序。

**语言特性**

- **Unicode 支持**：Go 原生支持 Unicode，能处理各国语言。

- **包与导入**：Go 代码通过包组织，`package`声明文件所属包，`import`导入其他包。`main`包用于定义独立可执行程序，`main`函数是程序执行起点。导入包需精确，缺失或多余导入会致编译失败，`import`声明要在`package`声明之后 。
- **函数声明**：由`func`关键字、函数名、参数列表、返回值列表（可空）和函数体组成。
- **语法格式**：Go 语言语句或声明后一般不用分号结尾（特殊情况除外）；对代码格式化要求严格，可使用`gofmt`工具格式化代码，`goimports`工具可按需管理导入声明。 还提到可通过`go get`命令获取`goimports`工具，多数 Go 操作可通过`go`工具实现。

# 命令行参数

程序常需处理输入产生输出，输入源多样，命令行参数是常见输入源之一 。Go 通过`os`包中的`os.Args`获取命令行参数，`os.Args`是字符串切片（slice） 。`os.Args[0]`是命令本身名字，`os.Args[1:]`是程序执行时传入参数 。

**echo**

```go
package main

import (
	"fmt"
	"os"
	"strings"
)

// echo1
func main() {
	var s, sep string
	for i := 1; i < len(os.Args); i++ {
		s += sep + os.Args[i];
		sep = " ";
	}
	fmt.Println(s);
}
```

- 导入`fmt`和`os`包，在`main`函数中，通过`for`循环遍历`os.Args[1:]` ，使用`+=`操作符将参数追加到字符串`s`中，参数间用空格分隔，最后通过`fmt.Println`输出所有参数 。

- Go 语言中变量声明（`var s, sep string` ）、操作符（`+=` ）以及`for`循环语法 。
- `for`循环有多种形式，`for initialization; condition; post` ，初始化、条件判断和后置操作部分可省略，可实现无限循环等 。

```go
// echo2
func main() {
	s, sep := "", ""
	for _, arg := range os.Args[1:] {
		s += sep + arg;
		sep = " ";
	}
	fmt.Println(s);
}

```

- 利用`range`关键字遍历`os.Args[1:]`，`range`会返回索引和对应元素值。当不需要索引时，可使用空白标识符`_` 。

- 短变量声明（如`s, sep := "", ""` ）以及等价的变量声明方式 。

```go
// echo3
func main() {
	fmt.Println(strings.Join(os.Args[1:], " "));
}
```

- 使用`strings.Join`函数，传入`os.Args[1:]`和分隔符`" "` ，可将命令行参数以指定分隔符连接成字符串输出，更为简洁高效 。

# 找出重复行

```go
// dup1
func main() {
	counts := make(map[string]int)
	input := bufio.NewScanner(os.Stdin)
	for input.Scan() {
		counts[input.Text()]++
	}
	for line, n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	}
}
```

- **功能**：输出标准输入中出现次数大于 1 的行，前面是出现次数 。
- **实现**：
  - 导入`bufio`、`fmt`、`os`包 。在`main`函数中，用`make`函数创建`map[string]int`类型的`counts`，用于统计每行出现次数。
  - 通过`bufio.NewScanner(os.Stdin)`创建扫描器`input`读取标准输入，`for input.Scan()`循环逐行读取，`counts[input.Text()]++`统计每行出现次数。
  - 再通过`for line, n := range counts`遍历`counts`，用`if n > 1`判断，若出现次数大于 1，使用`fmt.Printf("%d\t%s\n", n, line)`格式化输出次数和行内容 。
- **相关知识**：介绍了`if`语句语法（条件部分不放在圆括号，程序体用大括号 ）；`map`数据结构（存储键值对，`make`新建，键类型任意可比较，值任意类型 ）；`bufio.Scanner`扫描器读取输入 ；`fmt.Printf`格式化输出（介绍常用占位符如`%d`、`%s`等 ） 。

```go
// dup2
func main() {
	counts := make(map[string]int)
	files := os.Args[1:];
	if len(files) == 0 {
		countsLines(os.Stdin, counts)
	} else {
		for _, arg := range files {
			f, err := os.Open(arg)
			if err != nil {
				fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
				continue
			}
			countsLines(f, counts)
			f.Close()
		}
	}
	for line, n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	}
}

func countsLines(f* os.File, counts map[string]int) {
	input := bufio.NewScanner(f)
	for input.Scan() {
		counts[input.Text()]++
	}
}
```

- **功能**：可从标准输入或指定文件列表读取，打印输入中多次出现的行的个数和文本 。
- **实现**：
  - 同样导入相关包，创建`counts`统计次数 。先判断命令行参数`os.Args[1:]`，若为空，直接统计标准输入`countLines(os.Stdin, counts)` 。
  - 若有参数，遍历参数列表，用`os.Open`打开文件，若打开失败用`fmt.Fprintf(os.Stderr, "dup2: %v\n", err)`输出错误信息并`continue`继续下一个文件 。打开成功则调用`countLines(f, counts)`统计行数，最后关闭文件`f.Close()` 。`countLines`函数逻辑和`dup1`类似，通过扫描器逐行读取统计 。
- **相关知识**：介绍`os.Open`返回文件指针和错误值，文件读取完需`Close`释放资源；简单错误处理方式 ；函数声明顺序可任意 ；`map`作为引用类型，函数中对其修改在调用处可见 。

```go
// dup3
func main() {
	counts := make(map[string]int)
	for _, filename := range os.Args[1:] {
		data, err := ioutil.ReadFile(filename)
		if err != nil {
			fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
			continue
		}
		for _, line := range strings.Split(string(data), "\n") {
			counts[line]++
		}
	}
	for  line, n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	} 
}
```

- **功能**：从指定文件读取，统计重复行 。
- **实现**：导包，遍历命令行参数`os.Args[1:]`，用`ioutil.ReadFile`读取文件内容到`data`，若失败输出错误信息并`continue` 。成功读取后，用`strings.Split(string(data), "\n")`按行分割内容，再遍历分割后的行统计次数并输出重复行 。
- **相关知识**：`ioutil.ReadFile`读取文件内容为字节切片，可转换为字符串；`strings.Split`分割字符串 。 