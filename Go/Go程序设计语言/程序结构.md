# 名称

**命名规则**：

- **通用规则**：函数、变量、常量、类型、语句标签和包的名称，开头须是字母（Unicode 字符 ）或下划线，后续可跟任意数量字符、数字和下划线，且区分大小写，如`heapSort`和`Heapsort`是不同名称 。
- **关键字**：Go 有 25 个关键字，如`break`、`case`、`func`等，只能用于语法规定处，不能作为名称 。

![image.png](https://s2.loli.net/2025/04/09/fjeaXJM9LI4nmRD.png)

- **预声明名称**：有一些预声明的常量（`true`、`false`、`iota`、`nil` ）、类型（`int`、`float32`、`bool`、`string`等 ）和函数（`make`、`append`、`len`等 ），这些名称虽可在声明中使用，但要注意冲突风险 。

![image.png](https://s2.loli.net/2025/04/09/lzuYM8c6rXOjUh5.png)

**可见性规则**

- 函数内声明的实体仅在函数局部有效；函数外声明的实体对包内所有源文件可见 。名称首字母大小写决定其在包间的可见性，大写开头的名称是导出的，可被包外程序引用，如`fmt`包的`Printf` ；包名一般由小写字母组成 。

**命名风格**

- **长度**：名称无长度限制，但习惯上，作用域小的局部变量倾向用短名称，如`i` ；作用域大的使用长且有意义的名称 。
- **格式**：Go 程序员常用 “驼峰式” 风格，由单词组合的名称用大写字母区分单词，如`QuoteRuneToASCII` ，而非下划线分隔形式；首字母缩写词通常保持相同大小写 。

# 声明

**声明的种类与作用**

- 声明用于给程序实体命名并设定属性，Go 语言主要有变量（`var`）、常量（`const`）、类型（`type`）和函数（`func`）这 4 种声明 。

**程序结构中的声明顺序**

- Go 程序由一个或多个`.go`文件组成，文件以`package`声明开头表明所属包，接着是`import`声明导入所需包，之后包级别的类型、变量、常量、函数声明顺序无严格要求 。

```go
package main

import "fmt"

const boilingF = 212.0

func main() {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %g°F or %g°C\n", f, c)
}
```

- `boiling`程序：展示了一个计算并输出水沸点（华氏温度和摄氏温度 ）的程序 。`const boilingF = 212.0`是包级常量声明 。包级声明在包内所有源文件可见，局部声明仅在声明所在函数内可见 。

```go
func main() {
	const freezingF, boilingF = 32.0, 212.0
	fmt.Printf("%g°F = %g°C\n", freezingF, fToC(freezingF))
	fmt.Printf("%g°F = %g°C\n", boilingF, fToC(boilingF))
}

func fToC(f float64) float64 {
	return (f - 32) * 5 / 9
}
```

- `ftoc`程序：实现华氏温度到摄氏温度的转换 。

# 变量

**变量声明的形式**

- 用`var`声明变量，通用形式为`var name type = expression` ，可省略类型或表达式之一，但不能都省略 。省略类型时，变量类型由初始化表达式决定；省略表达式时，变量初始值为对应类型零值 。如`var s string` ，`s`初始值为空字符串 。

**零值机制**

- Go 语言中所有变量都有零值，数字为 0，布尔值为`false` ，字符串为`""` ，接口和引用类型（切片、指针、映射、通道、函数 ）为`nil` ，复合类型（数组、结构体 ）零值是其元素或成员零值 。零值机制**避免未初始化变量问题**，简化代码 。

**变量列表声明**

- 可同时声明多个变量并初始化，如`var i, j, k int`声明三个`int`类型变量，`var b, f, s = true, 2.3, "four"`省略类型声明不同类型变量 。

**变量初始化方式**

- 初始值可以是字面量或任意表达式 。包级变量初始化在`main`函数开始前进行，局部变量在函数执行期间初始化 。还可通过调用返回多个值的函数初始化变量，如`var f, err = os.Open(name)` ，`os.Open`返回文件和错误值 。

## 短变量声明

**形式与原理**

- 在函数中，短变量声明用`name := expression`形式声明和初始化局部变量 ，变量`name`的类型由表达式`expression`的类型决定 。如`anim := gif.GIF{LoopCount: nframes}` ，`anim`类型由`gif.GIF`结构体类型确定 。

**适用场景与对比**

- 因其简洁灵活，主要用于局部变量声明和初始化 。`var`声明则多用于变量类型与初始化表达式类型不一致，或初始值不重要、后续才赋值的情况 。

**多个变量声明**

- 可同时声明多个变量并初始化，如`i, j := 0, 1` ，但要注意仅在对可读性有帮助时使用 ，比如`for`循环初始化 。同时要区分`:=`（声明 ）和`=`（赋值 ），避免与多重赋值混淆 。

**调用多返回值函数**

- 短变量声明可用于调用像`os.Open`这样返回多个值的函数，如`f, err := os.Open(name)` ，获取文件和错误值 。

**注意事项**

- 短变量声明不一定要声明所有左边变量，若已有变量在同一词法块中声明，新声明等同于赋值 。例如`in, err := os.Open(infile)`声明新变量，`out, err := os.Create(outfile)`中`err`已有声明则为赋值 。
- 短变量声明至少声明一个新变量，否则编译报错 ，如`f, err := os.Open(infile)` ；`f, err := os.Create(outfile)`（错误，无新变量 ） 。

## 指针

**基本概念**

- **定义**：指针的值是变量的地址，可在不知变量名字时间接读取或更新变量值 。如变量`var x int` ，`&x`获取指向`x`的指针，类型为`*int` ，指针`p`指向`x`时，`*p`可获取或更新`x`的值 。
- **零值与比较**：指针类型零值是`nil` ，测试`p != nil`可判断指针是否指向变量 。两个指针仅在指向同一变量或都为`nil`时相等 。

**指针与变量**

- 聚合类型变量（结构体成员、数组元素 ）都是变量，有地址 。变量的表达式是唯一能应用取地址操作符`&`的表达式 。

**函数与指针**

- **返回局部变量指针**：函数可返回局部变量地址，且局部变量在函数返回后依然存在，如`func f() *int`返回指向局部变量`v`的指针 。
- **指针作为函数参数**：传递指针参数给函数，能让函数更新间接传递的变量值 ，如`func incr(p *int) int`函数递增指针所指变量值并返回新值 。

**在`flag`包中的应用**

指针在`flag`包中很关键，用于通过命令行参数设置程序内变量值 。

```go
var n = flag.Bool("n", false, "omit trailing newline")
var sep = flag.String("s", " ", "sparator")

func main() {
	flag.Parse()
	fmt.Print(strings.Join(flag.Args(), *sep))
	if !*n {
		fmt.Println()
	}
}
```

**实现**：`var n = flag.Bool("n", false, "omit trailing newline")`和`var sep = flag.String("s", " ", "separator")`创建布尔和字符串标识变量，`n`和`sep`是指针，需通过`*n`和`*sep`访问 。运行程序时，先调用`flag.Parse`更新标识变量默认值，非标识参数可从`flag.Args()`获取 ，若`flag.Parse`出错，程序输出帮助信息并以`os.Exit(2)`结束 。

## new 函数

**功能与用法**

- `new(T)`用于创建一个未命名的`T`类型变量，初始化为`T`类型的零值，并返回其地址（地址类型为`*T` ）。例如`p := new(int)` ，创建了一个未命名的`int`类型变量，`p`是指向该变量的指针，初始值为 0 ，后续可通过`*p`操作该变量，如`*p = 2`修改其值 。

**与普通变量声明对比**

- 用`new`创建的变量和普通局部变量取地址操作类似，只是无需为变量命名，属于语法上的便利，并非基础概念 。如`func newInt() *int { return new(int) }`和`func newInt() *int { var dummy int; return &dummy }` ，二者功能相同 。

**调用特性**

- 每次调用`new`返回具有唯一地址的不同变量，如`p := new(int); q := new(int); fmt.Println(p == q)`输出`false` 。但对于类型不携带信息且为零值的情况（如`struct{}`或`[0]int` ），当前实现中它们地址相同 。

**使用频率与重定义**

- 因最常见未命名变量多为结构体类型，语法较复杂，所以`new`函数使用相对较少 。
- `new`是预声明函数，不是关键字，可在函数内重定义为其他类型，如`func delta(old, new int) int { return new - old }` ，但在此函数内，内置`new`函数不可用 。

## 变量的生命周期

**包级别变量**：生命周期贯穿整个程序执行时间 。

**局部变量**：具有动态生命周期，每次执行声明语句时创建新实体，当变量变得不可访问时，其占用存储空间被回收 。函数参数和返回值也属于局部变量，在函数被调用时创建 。

**垃圾回收与变量可达性**

- 垃圾回收器通过追踪变量的引用路径判断是否回收变量 。包级别变量和当前执行函数的局部变量可作为追溯源头，若变量路径不存在即不可访问，就会被回收 。局部变量生命周期取决于其是否可达，即便包含它的循环结束，只要仍可达，就可能继续存在 。

**变量的存储分配**

- 编译器可选择在堆或栈上分配变量空间，此选择并非基于`var`或`new`关键字 。

```go
var global *int
func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```

- 函数`f`中局部变量`x` ，因在函数返回后仍可通过`global`变量访问（即从`f`中逃逸 ），所以使用堆空间；而函数`g`中用`new`创建的变量`*y` ，在函数返回后不可访问，编译器可在栈上分配 。
- 理解变量逃逸概念对性能优化有帮助，变量逃逸需额外内存分配 。同时垃圾回收虽有助于编写正确程序，但要关注内存负担，了解变量生命周期对编写高效程序很重要，避免长生命周期对象持有短生命周期对象不必要的指针，影响垃圾回收 。

# 赋值

**基本形式**：赋值语句用于更新变量的值，最简形式由赋值符`=`、左边变量和右边表达式组成 。多种赋值场景：

- **有名称变量**：如`x = 1` ，直接给变量`x`赋值 。
- **间接变量（指针 ）**：`*p = true` ，通过指针`p`给其所指变量赋值 。
- **结构体成员**：`person.name = "bob"` ，给结构体`person`的`name`成员赋值 。
- **数组、切片或映射元素**：`count[x] = count[x] * scale` ，更新对应索引处元素值 。

**赋值操作符**

- 算术和二进制位操作符都有对应的赋值操作符，如`count[x] *= scale`等价于`count[x] = count[x] * scale` ，可避免表达式中重复书写变量 。

**数字++和--**

- 数字变量可通过`++`和`--`进行递增递减操作 ，`v++`等同于`v = v + 1` ，`v--`等同于`v = v - 1` 。Go 中没有前置`++`和`--`，只有后置`++`和`--`，且无返回值。

## 多重赋值

**概念**：允许一次给多个变量赋值，在实际更新变量前，会先推演右边所有表达式 。

**应用场景**：

- **交换变量值**：如`x, y = y, x` ，可直接交换`x`和`y`的值；`a[i], a[j] = a[j], a[i]`用于交换数组元素 。
- **计算最大公约数**：在`gcd`函数中，`for y != 0 { x, y = y, x%y }` ，通过多重赋值不断更新`x`和`y`的值来计算最大公约数 。
- **计算斐波那契数列**：`fib`函数里，`for i := 0; i < n; i++ { x, y = y, x+y }` ，利用多重赋值迭代计算斐波那契数列第`n`个数 。
- **紧凑赋值序列**：如`i, j, k = 2, 3, 5` ，可一次性给多个变量赋值 。

**注意**：从风格上，若表达式复杂，建议避免使用多重赋值，用独立语句更易读 。当赋值语句中使用有多个返回值的函数调用时，左边变量个数要与函数返回值个数一致，如`f, err = os.Open("foo.txt")` 。

**特殊情况**：

- 函数常通过额外返回值指示错误等情况 。
- 一些操作（map 查询、类型断言、通道接收 ）在赋值语句中会产生额外布尔型结果，如`v, ok = m[key]`（map 查询 ）、`v, ok = x.(T)`（类型断言 ）、`v, ok = <-ch`（通道接收 ） 。
- 如同变量声明，可将不需要的值赋给空白标识符`_` ，如`_, err = io.Copy(dst, src)`（丢弃字节个数 ）、`_, ok = x.(T)`（检查类型但丢弃结果 ） 。

## 可赋值性

- **显式赋值**：通过赋值语句（如`x = 1` ）进行的赋值操作 。
- **隐式赋值**：函数调用时将参数值赋给对应参数变量、`return`语句将操作数赋给结果变量，以及复合类型字面量表达式对元素的赋值（如`medals := []string{"gold", "silver", "bronze"}` ，等同于`medals[0] = "gold"; medals[1] = "silver"; medals[2] = "bronze"` ） 。`map`和通道元素也有类似隐式赋值 。

**可赋值性规则**

- 无论是隐式还是显式赋值，当左边变量和右边值的类型相同时，赋值合法 ，即值对于变量类型可赋值时才合法 。对于已讨论类型，类型需精准匹配，`nil`可赋给任何接口变量或引用类型 。常量有更灵活可赋值性规则以避免显式转换 。

**与比较操作的关系**

- 两个值用`==`和`!=`比较时，与可赋值性相关，比较中第一个操作数相对于第二个操作数的类型必须是可赋值的，或可反向赋值 ，后续引入新类型时会解释其可比较性规则 。

# 类型声明

- **概念**：用`type`声明定义新的命名类型，与某个已有类型使用相同底层类型 ，形式为`type name underlying - type` 。
- **作用**：区分底层类型的不同使用场景，避免混淆 。例如，在温度转换程序中，定义`type Celsius float64`和`type Fahrenheit float64` ，虽底层类型都是`float64` ，但分别代表摄氏温度和华氏温度，防止不同计量单位温度值的无意合并 。

- **类型转换操作**：每个类型`T`都有对应的类型转换操作`T(x)` ，将值`x`转换为类型`T` 。如`Celsius(t)`和`Fahrenheit(t)`是类型转换，不会改变值和表达方式，仅改变显式意义 。
- **类型转换规则**：具有相同底层类型或指向相同底层类型变量的未命名指针类型可相互转换，且不改变值的表达方式 。数字类型、字符串和一些切片类型间转换会改变值的表达方式，如浮点型转整型会丢失小数部分 ，但运行时转换不会失败 。

**比较与操作**

- 命名类型的值可与其相同类型的值或底层类型相同的未命名类型的值，通过`==`和`<`等比较操作符进行比较 ，不同命名类型的值不能直接比较 。
- 命名类型可使用与底层类型相同的算术操作符 ，如`Celsius`和`Fahrenheit`类型可进行与`float64`相同的算术运算 。

**类型的方法关联**

- 以`Celsius`类型为例，可声明关联方法，如`func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }` ，当通过`fmt`包输出变量时，可控制类型值的显示方式 。

# 包和文件

- **作用**：类似于其他语言的库或模块，用于支持模块化、封装、编译隔离和重用 。
- **概念**：包的源代码存于一个或多个`.go`文件，所在目录名尾部是包的导入路径 。包为声明提供独立命名空间，不同包中同名函数互不干扰 。通过控制标识符是否以大写字母开头，管理其对外可见性（导出标识符大写开头 ） 。

**包的示例**

```go
package tempconv

import "fmt"

type Celsius float64
type Fahrenheit float64

const (
	AbsoluteZeroC Celsius = -273.15
	FreezingC     Celsius = 0
	BoilinfC      Celsius = 100
)

func (c Celsius) String() string    { return fmt.Sprintf("%g°C", c) }
func (f Fahrenheit) String() string { return fmt.Sprintf("%g°F", f) }
```

```go
package tempconv

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c * 9 / 5 + 32)}

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9)}
```

以温度转换功能创建`gopl.io/ch2/tempconv`包为例：

- **文件构成**：包内有`tempconv.go`和`conv.go`两个文件 。`tempconv.go`声明了`Celsius`和`Fahrenheit`类型、相关常量，以及类型的`String`方法 ；`conv.go`包含温度转换函数`CTOF`和`FTOC` 。
- **包的使用**：每个文件开头用`package`声明包名 。导入包后，可通过`包名.成员名`方式引用包内成员，如`tempconv.CToF` 。包级常量若大写开头，也可通过修饰名（如`tempconv.AbsoluteZeroC` ）访问 。
- **文档注释**：包声明前应紧跟文档注释描述整个包，习惯在开头用一句话总结，一个包通常只有一个文件含文档注释，扩展注释一般放于名为`doc.go`的文件中 。

## 导入

**概念**

- 在 Go 程序中，每个包通过导入路径（import path ）这一唯一字符串标识，如`"gopl.io/ch2/tempconv"` 。语言规范未定义其来源和含义，由工具解释 。导入路径标注目录，该目录含包的`.go`源文件 。包名通常与导入路径最后一段匹配，如`gopl.io/ch2/tempconv`包名是`tempconv` 。

**示例**

```go
package main

import (
	"fmt"
	"os"
	"strconv"

	"gopl.io/ch2/tempconv"
)

func main() {
	for _, arg := range os.Args[1:] {
		t, err := strconv.ParseFloat(arg, 64)
		if err != nil {
			fmt.Fprintf(os.Stderr, "cf: %v\n", err)
			os.Exit(1)
		}
		f := tempconv.Fahrenheit(t)
		c := tempconv.Celsius(t)
		fmt.Printf("%s = %s, %s = %s\n",
			f, tempconv.FToC(f), c, tempconv.CToF(c))
	}
}
```

- 以`cf`程序为例，它导入`"gopl.io/ch2/tempconv"`包，将命令行参数转换为摄氏温度和华氏温度 。在`main`函数中，遍历命令行参数，先将参数转换为浮点数，再分别转换为`Fahrenheit`和`Celsius`类型，最后输出转换后的温度值 。
- 导入声明可给导入的包绑定短名字（默认是包名 ），用于在文件中引用包内容，如`tempconv.CToF` 。也可设定可选名字避免冲突 。

**检查机制**

- 若导入包但未在代码中引用，会触发错误，这有助于消除不再需要的依赖 。如调试时注释掉对包唯一引用的代码，会导致编译器报错，此时需注释或删除不必要的`import` 。

## 包初始化

**变量**

- 包的初始化从包级变量开始，变量按声明顺序初始化，在依赖解析完成后，依据依赖顺序进行 。例如`var a = b + c` 、`var b = f()` 、`var c = 1` 、`func f() int { return c + 1 }` ，先初始化`c`为 1 ，再调用`f`初始化`b`为 2 ，最后初始化`a`为 3 。若包由多个`.go`文件组成，初始化按编译器接收文件顺序进行（`go`工具会在调用编译器前对文件排序 ） 。

**`init`函数**

- 对于一些初始化表达式不只是简单设置初始值的变量（如数据表 ），可使用`init`函数 。任何文件可包含任意数量`init`函数，其不能被调用或引用，在程序启动时，按声明顺序自动执行 。
- 包的初始化按导入顺序进行，依赖顺序优先，被导入包先完成初始化 ，`main`包最后初始化 ，确保在`main`函数执行前所有包初始化完毕 。

**示例**

```go
package popcount

var pc [256]byte

func init() {
	for i := range pc {
		pc[i] = pc[i / 2] + byte(i&1)
	}
}

func Popcount(x uint64) int {
	return int(pc[byte(x >> (0 * 8))] +
		pc[byte(x >> (1 * 8))] +
		pc[byte(x >> (2 * 8))] +
		pc[byte(x >> (3 * 8))] +
		pc[byte(x >> (4 * 8))] +
		pc[byte(x >> (5 * 8))] +
		pc[byte(x >> (6 * 8))] +
		pc[byte(x >> (7 * 8))])
}
```

- 以`popcount`包为例，定义了`PopCount`函数用于统计`uint64`值中置位个数 。通过`init`函数预先计算结果表`pc` ，`PopCount`函数利用该表计算，避免 64 步计算 。`init`函数中`for i := range pc`循环只使用索引，也可写成`for i, _ := range pc` 。

# 作用域

**与生命周期的区别**

- 声明的作用域是在程序文本中声明名字出现的区域，是编译时属性；变量的生命周期是变量在程序执行期间能被引用的起止时间，是运行时属性 。

- **语法块**：由大括号包围的语句序列，如循环体、函数体等，内部声明变量对外不可见 。
- **词法块**：可推广到没显式大括号包含的声明代码，包括全局块（含全部源代码 ）、包、文件、`for`、`if`、`switch`语句及`switch`和`select`语句中的条件部分 。显式大括号代码块也属词法块 。

**作用域规则**

- 声明的词法块决定其作用域大小 。内置类型、函数、常量在全局块声明，对整个包可见，可在包内任何文件引用 。包级声明在包内文件可见 ，局部声明（如函数内变量声明 ）仅在声明所在函数或部分语句内可用 。控制流标签（`break`、`continue`、`goto`使用的标签 ）作用域是外层函数 。
- 不同词法块可声明同名实体 ，但要避免滥用 。编译器从最内层封闭词法块到全局块查找名字声明，若未找到报 “undeclared name” 错误，内层声明会覆盖外层 。

**词法块嵌套与变量作用域**

- 函数内词法块嵌套深，局部变量声明可能覆盖其他声明 。如`for`循环创建显式和隐式词法块，隐式词法块中声明变量作用域包括条件、后置语句及循环体本身 。`if`和`switch`语句也会创建隐式词法块，条件对应一个块，每个`case`语句体对应一个块 ，且隐式词法块中初始化部分声明变量在后续语句可能不可见 。

**包级别声明与作用域**

- 包级别声明顺序和作用域无关，可引用自身或后面声明（如递归类型和函数 ），但常量或变量声明引用自身会报错 。同时局部变量在`if`语句中作用域相关编译错误及解决办法 ，**短变量声明对作用域的依赖** 。

```go
var cwd string
func init() {
    // cwd, err := os.Getwd() // 错误
    var err error
    cwd, err  = os.Getwd() // 正确
    // ...
}
```

> 参考资料：《Go程序设计语言》