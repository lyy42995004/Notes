# Mobvista汇量科技 9.26（OC）

1. OS：Linux命令❌（文件：ls，cd，mkdir，rm，cp，mv，cat，chmod；系统：ps，top，kill，ping，ip，netstat）

2. 手撕：[283. 移动零](https://leetcode.cn/problems/move-zeroes/)✅️

3. 手撕：❌

   ```
   使用并发方式进行消费:
   var events []string
   events= GetAllEvents()
   消费函数可使用伪函数代替:
   send(event string) {fmt.print(event)
   ```

   ```go
   package main
   
   import (
   	"fmt"
   	"sync"
   )
   
   // 模拟获取事件列表的函数
   func GetAllEvents() []string {
   	events := make([]string, 100)
   	for i := range events {
   		events[i] = fmt.Sprintf("事件-%d", i+1)
   	}
   	return events
   }
   
   // 消费单个事件的函数（根据您的图片中的 send 函数）
   func send(event string) {
   	// 这里替换成您实际的处理逻辑，例如调用API、写入数据库等
   	fmt.Println("处理:", event)
   }
   
   func main() {
   	// 1. 获取事件列表（与图片中代码一致）
   	var events []string
   	events = GetAllEvents()
   
   	// 2. 创建WaitGroup用于等待所有协程完成
   	var wg sync.WaitGroup
   
   	// 3. 使用带缓冲的channel来控制并发协程的数量为100
   	workerCount := 100
   	// eventsChan 是一个用于传递事件的channel
   	eventsChan := make(chan string, workerCount)
   
   	// 4. 启动100个 worker 协程（消费者）
   	for i := 0; i < workerCount; i++ {
   		wg.Add(1) // 为每个worker协程增加计数
   		go func(workerID int) {
   			defer wg.Done() // 协程结束时通知WaitGroup任务完成
   			// 从channel中循环接收事件并进行处理
   			for event := range eventsChan {
   				send(event)
   				// 可以在这里打印协程ID以观察并发情况
   				// fmt.Printf("Worker %d 处理了 %s\n", workerID, event)
   			}
   		}(i)
   	}
   
   	// 5. 将事件发送到channel（生产者）
   	for _, event := range events {
   		eventsChan <- event
   	}
   	// 关闭channel，告知所有worker协程已无新数据
   	close(eventsChan)
   
   	// 6. 等待所有worker协程处理完毕
   	wg.Wait()
   	fmt.Println("所有事件已处理完毕！")
   }
   ```

# 小红书 二面 数据库平台开发 9.25

1. 计网：UDP和TCP的区别✅️（连接性，可靠性，传输效率，TCP机制，应用场景）
2. 计网：除TCP三次握手，四次挥手外，TCP保证连接可靠性的办法？❌（ACK序列号，超时重传，**数据校验和**）
3. OS：进程和线程的联系和区别❌（联系：**包含关系**，资源分配；区别：资源开销，内存隔离，**通信机制**）
4. OS：同步和异步的区别❌（机制：同步是顺序且阻塞的，异步是并发且非阻塞的；**系统性能和资源**）
5. C++项目：讲一下C++项目❌
6. C++项目：日志系统单例模式解决什么问题❌（**避免资源冲突**，**节省系统资源**，**保持行为一致**）
7. OS：Reactor和Preactor的区别❌（**Reactor** 是**非阻塞I/O + 事件驱动**，**Proactor** 是**异步I/O + 完成回调**）
8. OS：epoll为什么高效？✅️（对比select，poll，epoll红黑树+就绪事件列表）
9. Go项目：按照目录讲解文件作用✅️
10. 项目：有没有线上部署的项目❌（部署失败）
11. 手撕：[300. 最长上升子序列](https://leetcode.cn/problems/longest-increasing-subsequence)✅️
12. 手撕：[ 114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list)✅️

# 小红书 一面 数据库平台开发 9.24

1. 自我介绍✅️
2. MySQL：连接池如何构建和维护的？长时间不用连接如何维护？❌（池化思想，一定的连接数；维护：后台线程检验定期心跳检查）
3. Go：高并发如何实现？❌（goroutine，GMP，**CSP**）
4. OS：协程和线程的区别❌（创建和开销，调度方式（线程**抢占式调度**、协程**协作式调度**），内存占用，通信机制； 协程实现，go有栈，C++无栈）
5. OS：协程没有内核态的切换，是如何调度的？❌(**协作式调度**主动让出，GMP)
6. OS：一个程序运行起来，存储在内存里面是怎么样的一个结构吗？❌（**代码段，数据段，BSS段， 堆，栈**；Go协程独立栈**在堆上**可自动扩容）
7. Go：协程用的哪一块数据？❌（Go协程**独立栈在堆上**可自动扩容）
8. Go：多协程共享数据怎么做？❌（提倡：通过通信共享内存chan；**传统**：通过共享内存进行通信mutex）
9. Go：协程不是有一个自己的栈区吗，那channel的数据存储在哪一个地方？✅️（堆上，栈上只有结构体）
10. MySQL：一条查询要经过什么才返回给用户✅️（连接器，解析器，优化器，执行器）
11. MySQL：一个查询语句里面可能会涉及多个索引，那他是在哪个步骤去选择，应该使用哪个索引？❌（优化器：**I/O 成本**、**CPU 成本**、**回表成本**）
12. MySQL：查询中有很多字段，如何去选择字段建立索引？❌（高频查询，高区分度，联合索引，覆盖索引，排序条件）
13. MySQL：哪些情况where不会命中索引？❌（函数，计算，类型转换，**not in**，左模糊查询，最左匹配原则， or连接非索引字段，**范围查询后，数据量过少**）
14. MySQL：in和not in会走索引吗，不知道的话，你觉得选择索引还是不选择使用，你怎么考虑呢？❌（**`IN`走**：转换为多个or；**`NOT IN`不走**）
15. Redis：底层哈希结构是什么样的？✅️（`ziplist`（压缩列表），`hashtable`（哈希表），渐进式哈希，两个哈希表，链地址法）
16. Redis：哈希表什么情况会进行扩容？❌（负载因子，链过长不会扩容）
17. 数据结构：哈希表链地址法，用链表和用红黑树的差异❌（复杂度，数据量，查询效率）
18. 手撕：[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)✅️
19. 手撕：[19. 删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list)✅️

> 数据结构，程序设计，**没有银弹**，各有优势，要看场景

# HelloTalk 9.5（OC）

> **忘记录屏了，要录屏！！！**

1. 自我介绍✅️
2. Go哪些情况会发生panic？❌（运行时：数组越界、空指针、除0 并发：关闭已经关闭的chan，先关闭的chan发数据）
3. 讲一下Go的GMP✅️（G-goroutine，M-os线程，P-逻辑处理器）
4. HTTPS为什么安全？✅️（TLS握手，非对称加密-》预主密钥，对称加密-》主密钥，**具体流程**）
5. HTTP1.1、HTTP2.0、HTTP3.0✅️（1.1长连接，2.0多路复用，3.0QUIC，UDP+TLS）
6. WebRTC技术❌（实时音视频技术：媒体采集，信令交换、建立连接、安全传输）
7. 讲一下MySQL索引✅️（聚簇、非聚簇，B+树，磁盘IO，回表，**索引优化**，**索引失效**）
8. Redis常见数据结构✅️（String，List，Hash，Set，Zset，GEO，Stream，Bitmap，HyperLogLog，**RedisObject**（类型，编码，lru，refcount，ptr，对应函数））
9. Redis的zset使用场景✅️（实时排行榜：游戏，商品）
10. 讲一下消息队列的使用✅️（异步，解耦，削峰，eg：电商）
11. Go项目：具体的实现✅️（websocket管理，上下线，单聊群聊消息转发）
12. Go项目：如何实现消息已读和未读？✅️（收到ack，添加字段，上线读消息ack/修改字段）
13. Go项目：实际生产环境中多个服务器，消息如何确定接收方的位置转发的？✅️（Redis 映射 + Kafka 转发 + 服务发现）

# 唱吧 9.5（OC）

> **SQL加强**

1. 自我介绍✅️

2. Go的context作用❌（控制Goroutine生命周期并传递数据：传播取消信号与超时控制、传递数据、设置处理时限）

3. 一个任务，要等待10个Goroutine的任务执行完之后，再执行要怎么做？❌（sync.WaitGroup，大小为10的channel）

4. 如果当一个Goroutine执行失败时，想让其他9个也退出执行，如何实现？❌（`context.Context`+ `sync.WaitGroup`，errorgroup）

5. protobuf压缩数据为什么能够减少网络带宽？❌（二进制，**数字标签取代字段名**，数值类型存储优化，字符串存储长度）

6. sql：exam表，student_id,lesson_id，score，class_id，查每个班级英语分数最高的学生

   ```sql
   SELECT e.student_id, e.class_id, e.score
   FROM exam e
   WHERE e.lesson_id = '英语'
   AND e.score = (
       SELECT MAX(score)
       FROM exam
       WHERE class_id = e.class_id
       AND lesson_id = '英语'
   );
   ```

7. sql：查所有不挂科的学生

   ```sql
   -- 方法一：使用 NOT EXISTS
   SELECT DISTINCT student_id
   FROM exam e1
   WHERE NOT EXISTS (
       SELECT 1
       FROM exam e2
       WHERE e1.student_id = e2.student_id
       AND e2.score < 60  -- 假设60分及格
   );
   
   方法二：使用 GROUP BY 和 HAVING
   SELECT student_id
   FROM exam
   GROUP BY student_id
   HAVING MIN(score) >= 60;  -- 确保所有科目都不低于60分
   
   方法三：使用 LEFT JOIN 和 IS NULL
   SELECT DISTINCT e1.student_id
   FROM exam e1
   LEFT JOIN (
       SELECT DISTINCT student_id
       FROM exam
       WHERE score < 60
   ) e2 ON e1.student_id = e2.student_id
   WHERE e2.student_id IS NULL;
   ```

8. 算法：[ 8. 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi)❌

# 东信时代 9.3

1. 自我介绍✅️
2. 输入URL到网页显示❌（1应用层：URL解析，DNS解析，构建HTTP，TLS握手 2传输层：TCP三次握手 3网络层：IP封装，路由转发 4数据链路层：mac寻址，帧封装 5物理层：电/光/无线信号）
3. Go项目：介绍项目架构？❌（前后端分离，model处理数据和业务逻辑，view前端展示，controller控制器接收HTTP请求调用服务层处理业务逻辑）
4. Go项目：多客户端同时接入如何支持？❌（1.HTTP-》websocket，map管理 2.心跳检测 3.读写goroutine 4.消息分发）
5. Go中map是否线程安全？✅️（不安全）
6. Go项目：用户连接保存在哪里？❌（websocket）
7. Go项目：用户不在线消息如何处理？❌（存储，上线调用getmessage读取mysql）
8. Go项目：客户端断开连接时如何感知和清理资源的？❌（心跳机制感知，defer自动释放资源。读协程：网络异常读函数出错，跳出循环。写协程：主循环监听到下线channel，写协程循环读因为channel关闭而结束）
9. Go中map加锁和用sync.Map区别?✅️（sync.Map读多写少，map+锁更好控制各种情况。 sync.Map底层维护read，dirty）
10. sync.Map扩容有没有做一些特殊处理？❌（read->dirty）
11. 一个非常大的map，想去扩容且无剩余空间了，要怎么做？❌（分片，提高负载因子，存指针，淘汰策略，改用redis）
12. Go协程和线程有什么区别？❌（调度方式，内存占用，创建和销毁，并行能力，通信机制）
13. Goroutine什么时候会泄露？❌（channel阻塞，无退出条件循环，死锁，为监听context取消，WaitGroup未配对）
14. context具体如何控制goroutine？❌（启动goroutine传入ctx，内部select监听ctx，三种方式：手动、超时、截止时间）
15. 向关闭的channel读写有什么问题？✅️（写panic，读完，返回false）
16. 怎么判断协程有没有关闭？❌（同步机制：关闭时发送channel，WaitGroup，Context.Done()，errgroup）
17. defer函数执行顺序，以及参数值是何时获取的？✅️（后进先出，普通函数直接获取，闭包函数获取最终值）
18. slice是否线程安全，添加元素的流程?✅️(不，大于2倍，按量扩容；容量小于258，扩容两倍，大于258，扩容至少1/4)
19. slice扩容是否会是新的地址？✅️（是）
20. Go项目：有哪些表，有什么关联关系？❌（消息表，用户表，好友表，群聊表，群聊成员表；消息和用户id/群聊id，一对多；用户和好友，多对多；用户和群聊，多对多；群主和群聊：多对多；）
21. Go项目：增加需求，如何判断用户有没有接收到消息?❌（添加是否已读字段，在线ack写MySQL，离线上线之后更新字段）
22. Go项目：假设数据库表很大，如何能让用户登录之后快速查找到消息？❌（限制查询量，时间加索引，时间分表，**引入redis缓存**）
23. Go项目：增加需求，当前聊天有多少条未读消息，如何实现，sql怎么写？❌（添加是否已读字段）

> **面试一定要录音，做复盘，不可能把面试问题全记住。**

# 北京尧创 9.2

1. 自我介绍✅️
2. 介绍两个项目❌
3. Go项目：消息如何传输以及存储的整个流程？❌（1消息序列化并发送 2服务端接收并处理 3消息分发，单聊和群聊）
4. Go项目：消息有哪些字段？❌（二者都有：发送方id，接收方id，内容，场景（单聊or群聊）内容类型（文字，图片...） proto：发送方用户名，头像 mysql：创建、更新、删除时间，图片存储路径，url）
5. Go项目：讲一下所有的表，以及如何关联的，哪些构建了索引？❌ （表：用户表，好友表，消息表，群聊表，群聊成员 关联关系：1用户与好友-多对多 2用户与群组-多对多 3消息与用户/群组 多对一 4群组与群主 一对多）
6. channel的类型❌（有缓冲or无缓冲）
7. 讲一下Redis❌（线程模型，数据结构，持久化，过期策略，内存淘汰策略，高可用主从、哨兵、集群，缓存问题击穿、穿透、雪崩）

# 深圳泉石净化科技 9.2

1. 自我介绍✅️
2. Go语言使用注意事项✅️（1.go不同版本，for中协程闭包函数值的获取 2.defer延迟函数后面普通函数和闭包函数中变量值区别 3. slice扩容导致产生新的slice）
3. 讲一下Go的map❌（概念：哈希表，引用类型，无序 底层：hmap，bmap 扩容机制：等量，增量，渐进式）
4. Go的所有类型❌（普通类型、引用类型）
5. Go的所有类型的空值❌（普通类型是零值，引用类型是nil）
6. websocket的优缺点❌（优：实时通信，开销低，支持二进制传输 缺：连接维持成本高，消息无可靠性）
7. protobuf的作用，对比其他序列化方式❌（1.序列化，二进制压缩，提高传输效率 2.兼容不同语言 3.协议向后兼容）
8. protobuf的使用方式❌（1.定义proto文件 2.生成代码 3.序列化发送 4.接收反序列化）
9. 什么是软删除❌(delete_at字段，标记删除时间)
10. Gorm一条语句如何写的❌（`db.Where("user_id = ?", userId).Find(&friends)`）

# 人民网 9.2

1. 自我介绍✅️

2. 介绍Go项目 ❌（RESTfulAPI前后端分离架构，后端Gin框架，Gorm操作数据库，功能：1.单聊群聊 2.多种消息类型 3.好友和群聊管理 技术：1实时通讯-》websocket 2传输效率-》protobuf 3高并发-》kafka（异步，削峰））

3. Go项目：100个在线用户，只有3-4用户在聊天，是如何处理websocket连接的？❌（1.连接建立并注册 map管理 2.客户端（前端） 定时发送心跳包 3.读写分离两个goroutine 4. 消息按需分发 5. goroutine占用资源少）

4. 三段代码运行结果题❌

   ```go
   func main() {
       s := []int{1, 2, 3}
       ss := s[1:]
       ss[0] = 99
       fmt.Println(ss) // [99, 3]
   }
   ```

   ```go
   func main() {
       v m map[string]int
       m["key"] = 42 // m未初始化，panic
       fmt.Println(m)
   }
   ```

   ```go
   for i := 0; i < 10; i++ {
       go func() {
           fmt.Println(i)
           // go1.20.x前 全是9
           // go1.21后   随机的0-9
       }()
   }
   time.Sleep(time.second)
   ```

