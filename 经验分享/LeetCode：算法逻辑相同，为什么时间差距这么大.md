> 在 LeetCode 上，服务器负载状况会对判题时间产生影响。比如，当评测机处于空闲状态时，可能会出现 0ms 的结果，通常情况下，4ms 和 0ms 的差距并不大。但这次**一道DP多状态问题**，我发现在算法逻辑相同，**一个是0ms，另一个甚至达到了100ms**，所以肯定是代码原因，下面我就来进行一下简单分析：

![image.png](https://s2.loli.net/2025/04/25/5hRaG1evFqbWJkd.png)

[740. **删除并获得点数**](https://leetcode.cn/problems/delete-and-earn/)

> 给你一个整数数组 `nums` ，你可以对它进行一些操作。
>
> 每次操作中，选择任意一个 `nums[i]` ，删除它并获得 `nums[i]` 的点数。之后，你必须删除 **所有** 等于 `nums[i] - 1` 和 `nums[i] + 1` 的元素。
>
> 开始你拥有 `0` 个点数。返回你能通过这些操作获得的最大点数。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [3,4,2]
> 输出：6
> 解释：
> 删除 4 获得 4 个点数，因此 3 也被删除。
> 之后，删除 2 获得 2 个点数。总共获得 6 个点数。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [2,2,3,3,3,4]
> 输出：9
> 解释：
> 删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
> 之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
> 总共获得 9 个点数。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 2 * 10^4`
> - `1 <= nums[i] <= 10^4`

**方法1**

```cpp
int deleteAndEarn(vector<int>& nums) {
    const int N = 1e4 + 5;
    vector<int> arr(N);
    for (int i = 0; i < nums.size(); ++i) {
        arr[nums[i]] += nums[i];
    }

    // dp[i][0]不选i的最大点数
    // dp[i][1]  选i的最大点数
    vector<vector<int>> dp(N, vector<int>(2));
    for (int i = 1; i < N; ++i) {
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]);
        dp[i][1] = dp[i-1][0] + arr[i];
    }
    return max(dp[N-1][0], dp[N-1][1]);
}
```

**方法2**

```cpp
int deleteAndEarn(vector<int>& nums) {
    const int N = 1e4 + 5;
    vector<int> arr(N);
    for (int i = 0; i < nums.size(); ++i) {
        arr[nums[i]] += nums[i];
    }

    // f[i]不选i的最大点数
    // g[i]  选i的最大点数
    vector<int> f(N);
    vector<int> g(N);
    for (int i = 1; i < N; ++i) {
        f[i] = max(f[i-1], g[i-1]);
        g[i] = f[i-1] + arr[i];
    }
    return max(f[N-1], g[N-1]);
}
```

# 运行时间差异分析

## 1. 内存访问模式

- 方法1（二维 `dp`）：
  - 使用 `dp[N][2]`，访问 `dp[i][0]` 和 `dp[i][1]` 时内存不连续。
  - 每次迭代需要跳转访问不同内存块，缓存命中率低。
- 方法2（两个一维数组）：
  - `f` 和 `g` 是独立数组，访问 `f[i]` 和 `g[i]` 时内存连续。
  - **CPU 缓存**预取更高效，减少缓存未命中（cache miss）。

## 2. 数据局部性

- 方法1：
  - 计算 `dp[i][0]` 和 `dp[i][1]` 需要**交替访问** `dp[i-1][0]` 和 `dp[i-1][1]`。
  - 数据依赖性高，可能限制指令级并行。
- 方法2：
  - `f[i]` 和 `g[i]` 的计算各自独立依赖前一状态，数据局部性更好。

## 3. 编译器优化

- 方法1：
  - 二维数组可能阻碍编译器优化（如循环展开、向量化）。
- 方法2：
  - 简单的一维数组更易被编译器优化（如自动向量化）。

# 内存消耗差异分析

- 方法1（约 53MB）
  - 使用 `vector<vector<int>>`，每个 `dp[i]` 额外存储指针开销。
- 方法2（约 22MB）
  -  两个 `vector<int>` 无额外指针开销。          

**总结**：**在处理简单的多状态动态规划（DP）问题时，最好把 DP 数组分开来存。这样做能让 CPU 更方便地访问数据，防止因数据交替访问，使得 CPU 的高级缓存没办法命中数据。而且分开存储或许还能让编译器更好地优化代码。另外，用二维 vector 数组会比用两个一维 vector 数组占的空间更多。**