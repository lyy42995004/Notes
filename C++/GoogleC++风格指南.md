# 前言

- [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)

- [Google 开源项目风格指南 - 中文版](http://github.com/zh-google-styleguide/zh-google-styleguide)

# 1.头文件

每个`.cc`文件应有一个配套的`.h`文件，单元测试和仅有`main()`函数的`.cc`文件是常见例外。

正确使用头文件会大大改善代码的可读性和执行文件的大小、性能。

## 1.1 自给自足的头文件

头文件应该自给自足 (可以独立编译)，并以 `.h` 为扩展名. 头文件要有头文件防护符 (1.2** **#define 防护符**)，并导入它所需的所有其它头文件。

若头文件声明了内联函数或模版，而且头文件的使用者需要实例化这些组件时，头文件必须直接或通过导入的文件间接提供这些组件的实现 。

> 内联函数的这种替换行为是在编译阶段发生的，编译器需要知道内联函数的完整定义才能进行替换操作。
>
> 模板的实例化是由编译器根据模板的使用情况在编译时完成的。和内联函数类似，编译器需要知道模板的完整定义才能进行实例化。

## 1.2 #define 防护符

所有头文件都应该用 `#define` 防护符来防止重复导入防护符的格式是: `项目>_<路径>_<文件名>_H_` 。

为了保证符号的唯一性，防护符的名称应该基于该文件在项目目录中的完整文件路径。例如，`foo` 项目中的文件 `foo/src/bar/baz.h` 应该有如下防护:

```c++
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
...
#endif  // FOO_BAR_BAZ_H_
```

## 1.3 导入你的依赖

若代码文件或头文件引用了其他地方定义的符号，该文件应该直接导入提供该符号的声明或者定义的头文件。不应该为了其他原因而导入头文件。

不要依赖间接导入. 这样，人们删除不再需要的 `#include` 语句时，才不会影响使用者. 此规则也适用于配套的文件: 若 `foo.cc` 使用了 `bar.h` 的符号，就需要导入 `bar.h`，即使 `foo.h` 已经导入了 `bar.h`。

## 1.4 前向声明

**定义**：前向声明 (forward declaration) 是**没有对应定义的声明**。

```C++
// 在 C++ 源码文件中：
class B; // 前向声明
void FuncInB();
extern int variable_in_b;
ABSL_DECLARE_FLAG(flag_in_b);
```

**优点**：节约编译时间、避免不必要的重复编译。

**缺点**：隐藏依赖关系、自动化工具识别困难、限制库的修改与维护、对`std::`命名空间的符号进行前向声明可能引发未定义行为、使用判断困难及代码含义改变风险、代码冗长与性能及复杂度问题。

尽量避免使用前向声明（弊大于利），应导入所需头文件。

## 1.5 内联函数

**只把 10 行以下的小函数定义为内联 (inline)。**

**优点:**只要内联函数体积较小，内联函数可以令目标代码更加高效。鼓励对存取函数用于**获取类中成员变量值的函数**）、变异函数（**用于修改类中成员变量值的函数**）和其它短小且影响性能的函数使用内联展开。

**缺点:**滥用内联将拖慢程序。根据函数体积，内联可能会增加或减少代码体积。通常，内联展开非常短小的存取函数会减少代码大小，但内联一个巨大的函数将显著增加代码大小。在现代处理器上，通常代码越小执行越快，因为指令缓存利用率高。

**注意**：谨慎对待析构函数。析构函数往往比表面上更长，因为会暗中调用成员和基类的析构函数！虚函数和递归函数通常不会被内联。

## 1.6 `#include` 的路径及顺序

推荐按照以下顺序导入头文件: 配套的头文件，C 语言系统库头文件，C++ 标准库头文件，其他库的头文件，本项目的头文件。

头文件的路径应相对于项目源码目录，不能出现 UNIX 目录别名 `.` (当前目录) 或 `..` (上级目录). 例如，应该按如下方式导入 `google-awesome-project/src/base/logging.h`:

```C++
#include "base/logging.h"
```

注意 C 语言头文件 (如 `stddef.h`) 和对应的 C++ 头文件 (`cstddef`) 是等效的。两种风格都可以接受，但是最好和现有代码保持一致。

举例来说，`google-awesome-project/src/foo/internal/fooserver.cc` 的导入语句如下:

```
#include "foo/server/fooserver.h"

#include <sys/types.h>
#include <unistd.h>

#include <string>
#include <vector>

#include "base/basictypes.h"
#include "foo/server/bar.h"
#include "third_party/absl/flags/flag.h"
```

**例外：**有时平台相关的代码需要有条件地导入，此时可以在其他导入语句后放置条件导入语句。 当然，尽量保持平台相关的代码简洁且影响范围小。 例如：

```C++
#include "foo/public/fooserver.h"

#include "base/port.h"  // 为了 LANG_CXX11.

#ifdef LANG_CXX11
#include <initializer_list>
#endif  // LANG_CXX11
```

# 2. 作用域

## 2.1 命名空间

**除了少数特殊情况，都应该在命名空间内放置代码。**命名空间应该有独一无二的名字，其中包含项目名称，也可以选择性地包含文件路径。**禁止使用 using 指令** (例如 `using namespace foo`)。 禁止使用内联命名空间。请参见**2.2 内部链接**中关于匿名命名空间的内容。

**定义**：命名空间可以将全局作用域 划分为独立的、有名字的作用域，因此可以有效防止全局作用域中的命名冲突。

**优点**：在大型程序里，不同项目或模块可能会定义同名的符号（比如都定义了名为`Foo`的类），若没有命名空间进行区分，在编译或运行时就会产生冲突。而将代码放置在各自的命名空间下（如`project1::Foo`和`project2::Foo`），就能让这些原本同名的符号成为不同作用域下的独立符号，避免了命名冲突，保障程序顺利运行。

内联命名空间会自动把其中的标识符置入外层作用域，比如：

```
namespace outer {
inline namespace inner {
    void foo();
}  // namespace inner
}  // namespace outer
```

此时表达式 `outer::inner::foo()` 与 `outer::foo()` 等效. 内联命名空间的主要用途是保持不同 ABI 版本之间的兼容性。

**缺点**：

- **理解难度增加**：命名空间的存在使得代码阅读和理解变得相对困难，因为要确定一个标识符对应的定义，需要清楚它所在的命名空间，可能涉及多层嵌套等情况，查找起来不如全局作用域下直观。

- **内联命名空间特殊问题**：内联命名空间更是加大了理解复杂度，其内部标识符不仅出现在自身声明的命名空间内，还会被置入外层作用域，导致代码逻辑的追踪变得更复杂，并且它主要用途局限于作为版本控制策略的一部分，适用场景较窄。
- **代码冗长问题**：在部分场景下，为了准确引用符号，需要使用完全限定名称，若命名空间存在多层嵌套，书写起来会让代码显得冗长，降低代码的简洁性。

**使用建议**

- **基本使用规范**：遵循命名空间命名规则，并且像示例那样通过注释注明命名空间名字，方便阅读代码时快速知晓。在导入语句、`gflags`声明 / 定义以及其他命名空间的类的前向声明完成后，用命名空间包裹整个源代码文件，无论是`.h`文件中的声明部分还是`.cc`文件中的函数定义部分，都放置在对应的命名空间内，保持代码结构清晰且符合规范。

```C++
// .h 文件
namespace mynamespace {

// 所有声明都位于命名空间中.
// 注意没有缩进.
class MyClass {
    public:
    ...
    void Foo();
};

}  // namespace mynamespace

// .cc 文件
namespace mynamespace {

// 函数定义位于命名空间中.
void MyClass::Foo() {
    ...
}

}  // namespace mynamespace
```

- **与标准库相关**：明确禁止在`std`命名空间内声明任何东西，也不要对标准库的类进行前向声明。
- **命名空间别名使用限制**：一般不允许头文件引入命名空间别名，除非是明显标注为内部使用的命名空间，
- **内联命名空间禁用**：明确禁止使用内联命名空间，避免引入不必要的代码维护和理解问题。
- **特定命名空间标识**：如果命名空间名称包含 “internal”，意味着这属于内部使用的 API，外部用户不应使用相关符号，以此来区分公开和内部的代码逻辑。

```C++
// Absl 以外的代码不应该使用这一内部符号.
using ::absl::container_internal::ImplementationDetail;
```

- **嵌套命名空间声明鼓励形式**：鼓励新代码采用单行的嵌套命名空间声明方式，这种形式相对简洁明了，符合代码书写的简洁性和规范性趋势。

```
namespace foo::bar {
...
}  // namespace foo::bar
```

## 2.2 内部链接

若其他文件不需要使用 `.cc` 文件中的定义，这些定义可以放入匿名命名空间或声明为 `static`，以实现内部链接。但是不要在 `.h` 文件中使用这些手段。

> 内部链接与声明为static类似。它们都将所修饰的实体（函数或者变量）的作用域限制在一个特定的编译单元（通常是一个`.cc`文件）内。

**定义**：所有放入匿名命名空间中的声明都会内部链接。声明为 `static` 的函数和变量也会内部链接。这意味着其他文件不能访问你声明的任何事物。即使另一个文件声明了一模一样的名称，这两个实体也都是相互独立的。

**结论**：建议 `.cc` 文件中所有不需要外部使用的代码采用内部链接。不要在 `.h` 文件中使用内部链接.匿名命名空间的声明应与具名命名空间的格式相同。在末尾的注释中，不用填写命名空间名称:

```
namespace {
...
}  // namespace
```

## 2.3 非成员函数、静态成员函数和全局函数

建议将非成员函数放入命名空间。尽量不要使用完全全局的函数。不要仅仅为了给静态成员分组而使用类。类的静态方法应当和类的实例或静态数据紧密相关。

**优点**：非成员函数和静态成员函数在某些情况下有用。若将非成员函数放在命名空间内，可以避免命名冲突，不会污染全局命名空间。

**缺点**：有时非成员函数和静态成员函数更适合成为一个新的类的成员，尤其是当它们需要访问外部资源或有明显的依赖关系时。

> 在良好的面向对象设计中，类应该是对具有紧密关联的属性和行为的封装。如果只是因为函数需要访问外部资源或有依赖关系就将非成员函数或静态成员函数随意纳入一个新类，可能会导致类的职责不明确。
>
> 从代码阅读者的角度来看，当一个类包含了很多原本作为非成员函数或静态成员函数添加进来的操作时，会使类的功能变得难以理解。

**结论**：有时我们需要定义一个和类的实例无关的函数，这样的函数可以定义为静态成员函数或非成员函数。非成员函数不应该依赖外部变量，且大部分情况下应该位于命名空间中。不要仅仅为了给静态成员分组而创建一个新类，这相当于给所有名称添加一个公共前缀，而这样的分组通常是不必要的。如果你定义的非成员函数仅供本 `.cc` 文件使用，请用**内部链接**限制其作用域。

## 2.4 局部变量

**应该尽可能缩小函数变量的作用域，并在声明的同时初始化。**

尽可能缩小变量的作用域, 且声明离第一次使用的位置越近越好。更容易找到声明, 了解变量的类型和初始值. 特别地, 应该直接初始化变量而非先声明再赋值, 比如:

```c++
int i;
i = f();     // 不好: 初始化和声明分离.
int i = f(); // 良好: 声明时初始化。
```

```C++
int jobs = NumJobs();
// 更多代码...
f(jobs);      // 不好: 初始化和使用位置分离.
```

```C++
int jobs = NumJobs();
f(jobs);      // 良好: 初始化以后立即 (或很快) 使用.
```

```C++
vector<int> v;
v.push_back(1);  // 用花括号初始化更好.
v.push_back(2);
```

```C++
vector<int> v = {1, 2}; // 良好: 立即初始化 v.
```

通常应该在语句内声明用于 `if`、`while` 和 `for` 语句的变量, 这样会把作用域限制在语句内. 例如:

```c++
while (const char* p = strchr(str, '/')) str = p + 1;
```

需要注意的是, 如果变量是一个对象, 那么它每次进入作用域时会调用构造函数, 每次退出作用域时都会调用析构函数.

```C++
// 低效的实现:
for (int i = 0; i < 1000000; ++i) {
    Foo f;  // 调用 1000000 次构造函数和析构函数.
    f.DoSomething(i);
}
```

在循环的作用域外面声明这类变量更高效:

```C++
Foo f;  // 调用 1 次构造函数和析构函数.
for (int i = 0; i < 1000000; ++i) {
    f.DoSomething(i);
}
```

## 2.5 静态和全局变量

**禁止使用静态储存周期的变量, 除非它们可以平凡地析构。**

> 平凡初始化：简单直接的初始化方式，通常在编译阶段就能完成大部分工作，不需要复杂的运行时操作。这种初始化方式主要涉及基本数据类型，如`int`、`char`、`float`等。
>
> 不平凡初始化：涉及复杂的操作，通常需要在运行时执行，并且可能包括动态内存分配、调用复杂的构造函数、从外部资源获取数据等来初始化对象。如`String`类的构造函数中，需要动态分配内存（`new char[length + 1]`）。
>
> 平凡析构：简单的析构函数，它不执行任何用户定义的、具有实质性影响的操作。
>
> 不平凡析构：在类中进行了资源分配（如动态内存分配、获取文件句柄、获取网络套接字等），在析构函数中就需要释放这些资源，以避免资源泄漏。

**定义**：每个对象都有与生命周期相关的储存周期。静态储存周期对象的存活时间是从程序初始化开始, 到程序结束为止。这些对象可能是命名空间作用域内的变量 (全局变量)、类的静态数据成员或者用 `static` 修饰符声明的函数局部变量。对于函数局部静态变量, 初始化发生在在控制流第一次经过声明时，所有其他对象会在程序启动时初始化。**程序退出时会销毁所有静态储存周期的对象 (这发生在未汇合 (join) 的线程终止前)。**

初始化过程可以是动态的, 也就是初始化过程中有不平凡的操作。其他初始化都是静态初始化。二者并非水火不容: 静态储存周期的变量 **一定** 会静态初始化 (初始化为指定常量或给所有字节清零), 必要时会随后再次动态初始化。

**优点**:静态储存周期的变量（特别是全局或静态变量）在很多场景下都能发挥作用，例如可充当具名常量方便代码中常量的使用和理解；作为编译单元内部的辅助数据结构来辅助实现某些功能；用于存储命令行旗标以控制程序不同的运行行为；记录日志信息；实现注册机制方便模块注册管理；搭建后台基础设施等，对程序整体的功能实现和结构组织有一定帮助。

**缺点**：

- **代码复杂度及错误风险**：使用动态初始化或者具有非平凡析构函数的全局和静态变量，会显著增加代码的复杂度。因为不同编译单元中这类变量的动态初始化顺序是不确定的，相应地析构顺序也不确定（只知道是初始化顺序的逆序），这就容易引发一些难以察觉的错误。
- **生命周期相关问题**：若静态变量的初始化代码引用了另一个静态储存周期的变量，可能出现访问时间在另一变量的生命周期开始前（导致访问未初始化的变量）或生命周期结束后（产生非法访问）的情况。而且在程序结束时，若存在未汇合的线程，这些线程可能在静态变量析构后继续尝试访问它们，进而引发程序错误。

平凡的析构函数不受执行顺序影响。其他析构函数则有风险, 可能访问生命周期已结束的对象。因此, 只有拥有平凡析构函数的对象才能采用静态储存周期。基本类型 (例如指针和 `int`) 可以平凡地析构, 可平凡析构的类型所构成的数组也可以平凡地析构。注意, 用 `constexpr` 修饰的变量可以平凡地析构。

> `constexpr`是 C++ 11 引入的一个关键字，用于指定一个表达式或函数在编译期可以求值。它主要用于常量表达式的计算，通过使用`constexpr`，可以让编译器在编译阶段尽可能地计算出表达式的值，而不是等到运行时再计算，从而提高程序的性能并且可以用于一些需要在编译期确定值的场景。

**关于析构**

```C++
const int kNum = 10;  // 允许

struct X { int n; };
const X kX[] = {{1}, {2}, {3}};  // 允许

void foo() {
  static const char* const kMessages[] = {"hello", "world"};  // 允许
}

// 允许: constexpr 可以保证析构函数是平凡的.
constexpr std::array<int, 3> kArray = {1, 2, 3};
```

```C++
// 不好: 非平凡的析构.
const std::string kFoo = "foo";

// 和上面相同的原因, 即使 kBar 是引用 (该规则也适用于生命周期被延长的临时对象).
const std::string& kBar = StrCat("a", "b", "c");

void bar() {
  // 不好: 非平凡的析构.
  static std::map<int, int> kData = {{1, 0}, {2, 0}, {3, 0}};
}
```

注意, 引用不是对象, 因此它们的析构函数不受限。但是, 它们仍需遵守动态初始化的限制。特别地, 我们允许形如 `static T& t = *new T;` 的函数内局部静态引用。

**关于初始化**

初始化是更复杂的话题, 因为我们不仅需要考虑构造函数的执行过程, 也要考虑初始化表达式的求值过程。

```C++
int n = 5;    // 可以
int m = f();  // ? (依赖 f)
Foo x;        // ? (依赖 Foo::Foo)
Bar y = g();  // ? (依赖 g 和 Bar::Bar)
```

除了第一行语句以外, 其他语句都会受到不确定的初始化顺序影响。

我们所需的概念在 C++ 标准中的正式称谓是常量初始化。这意味着初始化表达式是常量表达式, 并且如果要用构造函数进行初始化, 则该构造函数也必须声明为 `constexpr`:

```C++
struct Foo { constexpr Foo(int) {} };

int n = 5;  // 可以, 5 是常量表达式.
Foo x(2);   // 可以, 2 是常量表达式且被选中的构造函数也是 constexpr.
Foo a[] = { Foo(1), Foo(2), Foo(3) };  // 可以
```

可以自由使用常量初始化。应该用 `constexpr` 或 `constinit` 标记静态变量的常量初始化过程. 应该假设任何没有这些标记的静态变量都是动态初始化的, 并谨慎地检查这些代码。

> `constinit`是 C++ 20 引入的一个关键字，用于声明具有静态存储期或线程存储期的变量的初始化是常量初始化。它主要用于确保变量在编译期进行初始化，并且这种初始化方式更加明确和严格，相比于其他初始化方式，`constinit`强调初始化的常量性和确定性。

作为反例, 以下初始化过程有问题:

```C++
// 下文使用了这些声明.
time_t time(time_t*);      // 不是 constexpr!
int f();                   // 不是 constexpr!
struct Bar { Bar() {} };

// 有问题的初始化.
time_t m = time(nullptr);  // 初始化表达式不是常量表达式.
Foo y(f());                // 同上
Bar b;                     // 被选中的构造函数 Bar::Bar() 不是 constexpr.
```

我们不建议且通常禁止动态地初始化全局变量。不过, 如果这一初始化过程不依赖于其他初始化过程的顺序, 则可以允许。若满足这一要求, 则初始化的顺序变化不会产生任何区别。例如:

```C++
int p = getpid();  // 若其他静态变量不会在初始化过程中使用 p, 则允许.
```

允许动态地初始化静态局部变量 (这是常见的)。

**常用的语法结构**

- **全局字符串**：如果需要具名的全局或静态字符串常量，可以采用`constexpr`修饰的`string_view`变量、字符数组或者指向字符串字面量的字符指针，因为字符串字面量本身具有静态储存周期，往往能满足相应需求。
- **动态容器**：对于像字典和集合等动态容器，若要以静态变量储存不变的数据，不建议使用标准库的动态容器（因其拥有非平凡的析构函数），可以考虑用平凡类型的数组替代（如`int`数组的数组用于模拟字典、数对的数组等），对于少量数据利用线性搜索并借助`absl/algorithm/container.h`中的工具实现常见操作，必要时保持数据有序采用二分查找法；若确实需要使用标准库动态容器，建议使用函数内局部静态指针的方式来处理。
- **智能指针**：智能指针（如`std::unique_ptr`和`std::shared_ptr`）由于在析构时有释放资源的操作，属于非平凡析构，不能作为静态变量使用，这种情况下可以思考是否适用其他模式，简单的解决办法是用裸指针指向动态分配的对象且永不删除它。
- **自定义类型的静态变量**：对于自定义类型的静态数据或常量数据，应给该类型设置平凡的析构函数以及`constexpr`修饰的构造函数，使其符合作为静态储存周期变量的条件；若上述各种建议都不适用，可以采用函数内局部静态指针或引用，通过动态分配一个对象且永不删除的方式来处理（如`static const auto& impl = *new T(args...);`）。

## 2.6 thread_local 变量
