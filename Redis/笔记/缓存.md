# 为什么用redis作为缓存？

**高性能和低延迟**：内存存储、单线程模型和高效的数据结构，使数据访问速度极快，延迟低。

**丰富的数据类型**：支持字符串、哈希、列表、集合等多种数据类型，操作灵活，适用于多样业务场景。

**高可用性与持久化**：支持 RDB、AOF 持久化方案，主从复制、哨兵机制和集群模式确保高可用性和数据安全。

**减轻数据库压力**：缓存热点数据，减少数据库访问频率，支持数据过期策略（LRU、LFU、TTL），合理利用内存资源。

**广泛应用场景**：用于会话缓存、排行榜、计数器、分布式锁、消息队列等。

**成熟的生态系统**：多语言支持，社区活跃，易于集成和维护。

# 内存淘汰策略

## **不淘汰策略**

| 策略 | 行为 |
|-|-|
| `noeviction`（**默认**） | 内存满时，新写入操作返回错误（如 `OOM`），读操作正常。 |
| `allkeys-random`     | 从**所有键**中随机删除一个，无论是否过期。 |

## **基于过期时间的策略**

| 策略 | 行为 |
|-|-|
| `volatile-random`      | 从**设置了过期时间的键**中随机删除一个。                    |
| `volatile-ttl`         | 优先删除**剩余存活时间最短（TTL最小）**的过期键。           |
| `volatile-lru`         | 从**设置了过期时间的键**中删除**最近最少使用（LRU）**的键。 |
| `volatile-lfu`（4.0+） | 从**设置了过期时间的键**中删除**最不频繁使用（LFU）**的键。 |

## **全局键淘汰策略**

| 策略 | 行为 |
|-|-|
| `allkeys-lru`         | 从**所有键**中删除**最近最少使用（LRU）**的键。 |
| `allkeys-lfu`（4.0+） | 从**所有键**中删除**最不频繁使用（LFU）**的键。 |

> **LRU（Least Recently Used）**
>
> - **原理**：优先淘汰最久未被访问的数据。
> - **Redis 实现**：近似 LRU，通过随机采样（默认5个键）选择最久未使用的键，平衡性能与精度。
>
> **LFU（Least Frequently Used）**
>
> - **原理**：优先淘汰访问频率最低的数据。
> - **Redis 实现**（4.0+）：
>   - 使用 Morris 计数器算法，统计访问频率。
>   - 支持衰减机制（`lfu-decay-time`）：随时间降低计数，避免历史热点数据长期占用内存。

# 缓存预热

## 是什么？

缓存预热是指在系统启动或重新上线时，提前将常用或热门数据加载到缓存中，避免系统启动初期因缓存未命中导致大量请求落到数据库，造成系统压力骤增。

## 如何产生？

- 系统刚启动或重启时，缓存为空，大量请求直接访问数据库，造成数据库压力大、响应慢，甚至宕机。

- 无预热策略的缓存系统，在流量高峰期无法承受瞬时冲击，影响用户体验。

## 如何解决？

- **手动预热**：通过脚本或后台任务提前加载数据（如商品详情、配置信息）。
- **日志分析**：结合业务特性，如将热点商品、用户常用信息等主动预热到缓存。
- **动态预热**：结合业务逻辑，在首次查询后异步填充缓存。

# 缓存穿透

## 是什么？

**查询不存在的数据**，导致请求绕过缓存直接访问数据库（如恶意请求不存在的 ID）。

## 如何产生？

- 恶意攻击：频繁请求无效 Key（如 `id=-1`）。
- 业务逻辑缺陷：未校验参数合法性。

## 如何解决？

- **缓存空值**：对不存在的 Key 缓存 `NULL` 或短 TTL 的空对象，避免重复查询数据库。
- **布隆过滤器（Bloom Filter）**：在缓存前加一层过滤器，快速判断 Key 是否存在。
- **参数校验**：拦截非法请求（如非正整数 ID）。

# 缓存击穿

## **是什么？**

**某个热点 Key 突然过期**，同时大量请求直接击穿到数据库，导致瞬时压力激增。

## **如何产生？**

- 热点 Key 过期时间设置不合理（如高峰期过期）。
- 未对热点数据做特殊处理。

## **如何解决？**

- **永不过期策略**：对极热点 Key 不设 TTL，通过逻辑过期（如后台异步更新）。
- **互斥锁**：在缓存失效时对访问同一 Key 的请求加锁，防止击穿。
- **提前刷新缓存**：在缓存过期前异步刷新或延长有效期，确保缓存命中率。

# 缓存雪崩

## 是什么？

**大量缓存 Key 同时过期** 或 **缓存服务宕机**，导致所有请求直接访问数据库，引发连锁故障。

## 如何产生？

- 缓存 Key 的 TTL 相同（如批量导入数据默认过期时间）。
- Redis 集群宕机或网络分区。

## 如何解决？

- **过期时间分散**：将缓存的过期时间随机化，避免大量缓存同时失效。
- **多级缓存**：结合本地缓存（Caffeine）和分布式缓存（Redis），降低单点风险。
- **降级限流**：在缓存失效或数据库异常时，快速降级，限制流量，保证系统稳定。
- **高可用架构**：Redis Cluster + Sentinel 避免全盘崩溃。


| 问题 | 核心原因 | 解决方案 |
| :----------- | :-- | :------------------- |
| **缓存预热** | 冷启动缓存为空             | 主动加载热点数据 |
| **缓存穿透** | 查询不存在的数据           | 布隆过滤器 + 缓存空值 |
| **缓存击穿** | 热点Key突然过期          | 互斥锁 + 永不过期 |
| **缓存雪崩** | 大量Key同时过期 | 差异化TTL + 多级缓存 |
|  | 服务宕机 | 降级限流 + 高可用架构 |
