Redis 中的 List（列表）类型是一种有序的数据结构，它可以存储多个字符串元素，并且这些元素按照插入顺序排列。可以将它理解为一个双向链表，支持在链表的两端进行快速的插入和删除操作。它允许元素重复，并且可以在列表的头部（左侧）或尾部（右侧）进行元素的添加和移除。

# 内部实现

## 压缩列表（ziplist）

- **结构**：是一种紧凑的连续内存块数据结构。它将列表元素依次存储，每个节点包含前一节点长度、当前节点长度和节点值等信息。
- **优点**：内存利用率高，没有额外指针开销，适合存储少量小元素列表，能有效节省内存。
- **缺点**：插入和删除元素时，可能需要移动大量数据，时间复杂度为 O (n)；查找元素也需遍历，效率低。

<img src="https://s2.loli.net/2025/03/25/Ohf67euKzdUDMGi.png" alt="image.png" style="zoom:67%;" />

## 双向链表

- **结构**：由多个节点组成，每个节点包含数据、指向前一个节点的指针和指向后一个节点的指针。
- **优点**：在链表两端进行插入和删除操作非常高效，时间复杂度为 O (1)，适合频繁插入和删除的场景。
- **缺点**：每个节点需要额外的指针来维护链表结构，内存开销大；且节点在内存中不连续存储，可能导致内存碎片化。

> **在Redis3.2版本之后，List数据类型底层数据结构就只由quicklist实现了，替代了双向链表和压缩列表。**

## 快速列表（quicklist）

- **结构**：结合了压缩列表和双向链表的优势。它是一个由多个压缩列表作为节点组成的双向链表。
- **优点**：既保持了在链表两端快速插入和删除的特性，又通过压缩列表存储元素节省了内存，减少了内存碎片化问题。
- **缺点**：结构相对复杂，在某些复杂操作时可能存在一定额外开销。

![image.png](https://s2.loli.net/2025/03/25/uaRnkxjUw5hVNHo.png)

# 常用命令

## 添加

**LPUSH**

```
lpush key element [element ...]
```

- 头插元素到`list`中，如果`key`不存在就创建，返回插入操作后列表的新长度。

**LPUSHX**

```
lpushx key element [element ...]
```

- 当列表键已经存在时头插元素到`list`中。

**RPUSH**

```
rpush key element [element ...]
```

- 尾插元素到`list`中，如果`key`不存在就创建，返回插入操作后列表的新长度。

**RPUSHX**

```
rpushx key element [element ...]
```

**LINSERT**

```
linsert key before|after pivot element
```

- 在列表里指定元素的前面或后面插入新元素。若操作成功，返回插入新元素后列表的长度；若指定的 `key` 不存在，返回 0；若 `pivot` 元素未在列表中找到，返回 -1。
- **参数**：
  - `BEFORE` 或者 `AFTER`：表明插入位置是在指定元素的前面还是后面。

  - `pivot`：为列表中作为参考的元素。

  - `element`：是要插入到列表中的新元素。


## 查找

**LRANGE**

```
lrange key start stop	
```

- 获取`[start, end]`的闭区间范围的`list`元素，支持负数下标。

**LINDEX**

```
lindex key index
```

- 获取指定下标的元素，并返回，支持负数下标。

**LLEN**

```
llen key
```

- 获取`list`的长度，并返回，如果不存在则返回0。

## 删除

**LPOP**

```
lpop key [count]
```

- 头删`list`元素，返回删除的元素，若列表为空则返回 `nil`。

**RPOP**

```
rpop key [count]
```

- 尾删`list`元素，返回删除的元素，若列表为空则返回 `nil`。

**LREM**

```
lrem key count element
```

- 删除`count`个`element`元素。

- 当 `count > 0` 时，从左往右，移除 `count` 个与 `value` 相等的元素。
- 当 `count < 0` 时，从右往左，移除 `|count|` 个与 `value` 相等的元素。
- 当 `count = 0` 时，移除列表中所有与 `value` 相等的元素。

**LTRIM**

```
ltrim key start stop
```

- 只保留`[start, stop]`闭区间内部的元素，其余的元素全部删除。

## 修改

**LSET**

```
lset key index element
```

- 将指定位置的元素替换为新值。若 `key` 不存在或者索引超出列表范围，会返回错误。

## 阻塞命令

在 Redis 中，阻塞命令是指那些会使客户端在一定条件下暂停执行，等待特定事件发生后才继续执行的命令。

**特点**：

- **暂停执行**：当客户端发送阻塞命令后，如果当前条件不满足立即执行的要求，客户端就会被阻塞，线程会被挂起，不再继续执行后续的命令，直到满足特定条件。
- **等待事件触发**：阻塞命令会一直等待某个特定事件的发生，例如有新元素加入列表（如`BLPOP`和`BRPOP`等待列表中有元素可弹出）、达到指定的超时时间等。一旦这些事件发生，阻塞状态就会被解除，客户端继续执行后续操作。
- **原子性**：阻塞命令通常是原子操作，即要么整个命令执行成功，要么由于阻塞条件不满足而不执行任何操作，不会出现部分执行的情况，保证了数据的一致性和完整性。

**作用**：

- **实现消息队列和任务队列**：在构建消息队列或任务队列时，生产者将任务或消息放入列表，消费者使用阻塞命令从列表中获取任务。消费者在没有任务时会阻塞等待，避免了轮询带来的资源浪费，当有新任务加入时，消费者能及时被唤醒并处理任务。
- **协调分布式系统中的操作**：在分布式系统中，多个节点可能需要协调操作。阻塞命令可以用于实现节点之间的同步，例如一个节点等待另一个节点完成某个操作后再继续执行，通过阻塞等待可以确保操作的顺序和一致性。

**BLPOP**

```
blpop key [key ...] timeout
```

- 读取并删除`list`头部元素，如果没有元素则陷入阻塞。

**BRPOP**

```
brpop key [key ...] timeout
```

- 读取并删除`list`头部元素，如果没有元素则陷入阻塞。

# 应用场景

**消息队列**：List 类型非常适合实现消息队列。生产者可以使用 `RPUSH` 命令将消息添加到列表的尾部，消费者使用 `LPOP` 命令从列表的头部获取消息，实现先进先出（FIFO）的消息处理机制。

**最新消息列表**：可以使用 `LPUSH` 命令将最新的消息添加到列表的头部，然后使用 `LRANGE` 命令获取最新的几条消息。例如，在社交应用中，可以使用 List 存储用户的最新动态。

**任务队列**：可以使用 List 作为任务队列。任务生产者将任务添加到列表中，任务消费者从列表中获取任务并执行。