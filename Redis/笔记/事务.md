# 基本命令

- **MULTI**：开启事务，之后的命令会放入队列，直到 `EXEC` 或 `DISCARD` 被调用。
- **EXEC**：执行事务中的所有命令。
- **DISCARD**：取消事务，清空命令队列。
- **WATCH**：监视一个或多个键，如果在事务执行前这些键被修改，事务将不会执行。

**事务执行流程**

1. **开启事务**：使用 `MULTI` 命令开启一个事务。在这个阶段，Redis 会标记当前客户端进入事务状态，并准备接收后续的命令。
2. **命令入队**：在事务开启后，客户端发送的所有命令都会被放入事务队列中，而不会立即执行。每个命令入队后，Redis 会返回 `QUEUED` 表示命令已成功入队
3. **执行事务**：使用 `EXEC` 命令执行事务队列中的所有命令。Redis 会按照命令入队的顺序依次执行这些命令，并将每个命令的执行结果返回给客户端。
4. **取消事务**：使用 `DISCARD` 命令取消当前事务，并清空事务队列。在取消事务后，客户端可以重新开始一个新的事务。

```
> MULTI
OK
> SET key1 value1
QUEUED
> SET key2 value2
QUEUED
> EXEC
1) OK
2) OK
```

**WATCH命令**

`WATCH` 用于实现乐观锁，监视一个或多个键，如果在事务执行前这些键被修改，事务将不会执行。

```
> WATCH key1
OK
> MULTI
OK
> SET key1 newvalue
QUEUED
> EXEC
(nil)
```

- 如果在 `MULTI` 之后、`EXEC` 之前 `key1` 被修改，事务将执行失败，返回 `(nil)`。
- 可以通过 `UNWATCH` 取消监控。

# 特性

- **原子性（Atomicity）**：Redis 事务可以保证一个事务中的所有命令要么都执行，要么都不执行。但是如果在事务执行过程中发生了运行时错误，**Redis 不会回滚事务**，而是继续执行后续命令，这与传统数据库的严格原子性有所不同。
- **一致性（Consistency）**：Redis 事务可以保证数据的一致性，前提是事务中的命令没有逻辑错误。
- **隔离性（Isolation）**：Redis 的事务是单线程执行的，这意味着在一个事务执行期间，不会有其他事务同时执行，从而避免了并发访问导致的数据不一致问题。
- **持久性（Durability）**：Redis 事务本身并不直接保证持久性。持久性取决于 Redis 所采用的持久化策略，如 RDB（快照）和 AOF（追加日志）。

# 应用场景

**库存管理**：在电商系统中，库存管理是一个重要的问题。使用 Redis 事务可以保证库存扣减操作的原子性，避免超卖问题。

**用户积分系统**：在用户积分系统中，使用 Redis 事务可以保证积分的增加和减少操作的原子性。