# 快速排序

## 简单

### [LCR 159. 库存管理 III](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)

> 仓库管理员以数组 `stock` 形式记录商品库存表，其中 `stock[i]` 表示对应商品库存余量。请返回库存余量最少的 `cnt` 个商品余量，返回 **顺序不限**。
>
> 
>
> **示例 1：**
>
> ```
> 输入：stock = [2,5,7,4], cnt = 1
> 输出：[2]
> ```
>
> **示例 2：**
>
> ```
> 输入：stock = [0,2,3,6], cnt = 2
> 输出：[0,2] 或 [2,0]
> ```
>
> 
>
> **提示：**
>
> - `0 <= cnt <= stock.length <= 10000`
> - `0 <= stock[i] <= 10000`

借助快排的思想划分出小于cnt的区间即可。

```C++
vector<int> inventoryManagement(vector<int>& stock, int cnt) {
    if (cnt == 0)
        return {};
    srand(time(nullptr));
    qsortK(stock, 0, stock.size() - 1, cnt);
    return {stock.begin(), stock.begin() + cnt};
}

// 借助快排思想，以k划分数组
void qsortK(vector<int>& stock, int left, int right, int k) {
    if (left == right)
        return;
    int key = stock[rand() % (right - left + 1) + left];
    int i = left, l = left, r = right;
    while (i <= r) {
        if (stock[i] < key)
            swap(stock[l++], stock[i++]);
        else if (stock[i] > key)
            swap(stock[r--], stock[i]);
        else
            i++;
    }
    // [left, l - 1] [l, r] [r + 1, right]
    if (k <= l - left)
        qsortK(stock, left, l - 1, k);
    else if (k <= r - left + 1)
        return;
    else
        qsortK(stock, r + 1, right, k - (r - left + 1));
    return;
}
```


## 中等

### [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

> 给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
>
> 我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。
>
> 必须在不使用库内置的 sort 函数的情况下解决这个问题。
>
> 
>
> **示例 1：**
>
> ```
> 输入：nums = [2,0,2,1,1,0]
> 输出：[0,0,1,1,2,2]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [2,0,1]
> 输出：[0,1,2]
> ```
>
> 
>
> **提示：**
>
> - `n == nums.length`
> - `1 <= n <= 300`
> - `nums[i]` 为 `0`、`1` 或 `2`

遍历数组，保持`[0, left - 1]`全为0，`[right + 1, nums.size() - 1]`全为2，最后`[left, right]`就全为1了。当`i > right`，就完成了数组划分，不用再继续遍历了。三种情况，对应操作：

- `nums[i] == 0`时，交换`nums[left]`与当前值并`i++`。
- `nums[i] == 1`时，`i++`即可。
- `nums[i] == 2`时，交换nums[left]，但不能`i++`，还要对交换得到值再进行判断。

```C++
void sortColors(vector<int>& nums) {
    int left = 0, right = nums.size() - 1;
    int i = 0;
    while (i <= right) {
        if (nums[i] == 0)
            swap(nums[left++], nums[i++]);
        else if (nums[i] == 1)
            i++;
        else // nums[i] == 2
            swap(nums[right--], nums[i]);
    }
}
```

### [912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

> 给你一个整数数组 `nums`，请你将该数组升序排列。
>
> 你必须在 **不使用任何内置函数** 的情况下解决问题，时间复杂度为 `O(nlog(n))`，并且空间复杂度尽可能小。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [5,2,3,1]
> 输出：[1,2,3,5]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [5,1,1,2,0,0]
> 输出：[0,0,1,1,2,5]
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 5 * 104`
> - `-5 * 104 <= nums[i] <= 5 * 104`

根据`rand()`随机生成的值作为下标找到`key`，借助[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)的思想以key将数组分为三个部分，`nums[i] < key`，`nums[i] == key`，`nums[i] > key`，不断递归即可实现快速排序。

将数组划分为三块而不是两块，避免数组全部相同时，快排时间复制度过高。

```C++
vector<int> sortArray(vector<int>& nums) {
    srand(time(nullptr));
    qsort(nums, 0, nums.size() - 1);
    return nums;
}

void qsort(vector<int>& nums, int left, int right) {
    if (left >= right) return;
    // 随机获取key
    int key = nums[rand() % (right - left + 1) + left];
    // 数组划分为三块
    int i = left, l = left, r = right;
    while (i <= r) {
        if (nums[i] < key)
            swap(nums[l++], nums[i++]);
        else if (nums[i] > key)
            swap(nums[r--], nums[i]);
        else 
            i++;
    }
    // [left, l - 1] [l, r] [r + 1, right]
    qsort(nums, left, l - 1);
    qsort(nums, r + 1, right);
}
```

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

> 给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。
>
> 请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。
>
> 你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。
>
>  
>
> **示例 1:**
>
> ```
> 输入: [3,2,1,5,6,4], k = 2
> 输出: 5
> ```
>
> **示例 2:**
>
> ```
> 输入: [3,2,3,1,2,4,5,5,6], k = 4
> 输出: 4
> ```
>
>  
>
> **提示：**
>
> - `1 <= k <= nums.length <= 105`
> - `-104 <= nums[i] <= 104`

借助快速排序的思想解决**topK问题**，快速选择将数组划分为三块，对应三种情况进行查找，不断递归即可：

```
[left, l - 1] [l, r] [r + 1, right]
```

- 当k小于等于右区间的长度，既`k <= right - r`时，继续在右区间查找第k大的数。
- 当k小于等于右区间＋中间相同字符的长度，既`k <= right - l + 1`时，第k大的数就在中间区间为`key`。
- 当k大于右区间＋中间相同字符的长度时，既k在左区间时，在左区间查找第k大的数减去右区间＋中间相同字符的长度，既第`k - (right - l + 1)`大的数。

```C++
int findKthLargest(vector<int>& nums, int k) {
    srand(time(nullptr));
    int left = 0, right = nums.size() - 1;
    return topK(nums, left, right, k);
}

int topK(vector<int>& nums, int left, int right, int k) {
    if (left == right)
        return nums[left];

    // 随机获取key
    int key = nums[rand() % (right - left + 1) + left];

    // 数组划分为三块
    int i = left, l = left, r = right;
    while (i <= r) {
        if (nums[i] < key)
            swap(nums[l++], nums[i++]);
        else if (nums[i] > key)
            swap(nums[r--], nums[i]);
        else
            i++;
    }

    // [left, l - 1] [l, r] [r + 1, right]
    if (k <= right - r)
        return topK(nums, r + 1, right, k);
    else if (k <= right - l + 1)
        return key;
    else
        return topK(nums, left, l - 1, k - (right - l + 1));
}
```

