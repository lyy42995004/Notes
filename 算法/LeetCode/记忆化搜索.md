**记忆化搜索**（Memoization）是一种优化递归算法的技术，通过存储已计算的结果来避免重复计算，从而显著提高效率。以下是其核心要点：

**核心思想**

- **空间换时间**：用额外的存储空间（如数组、哈希表）记录子问题的解，下次遇到相同问题时直接查表，无需重新计算。
- **避免重复计算**：特别适用于**重叠子问题**（如斐波那契数列、动态规划问题）。

**适用场景**

1. **递归问题**：存在大量重复子问题的递归调用（例如斐波那契数列、组合数计算）。
2. **动态规划**：常作为自顶向下（Top-Down）DP的实现方式。
3. **搜索优化**：在DFS等搜索中缓存中间状态（如棋盘路径问题）。

**实现步骤**

1. **定义存储结构**：如数组`memo[]`或哈希表。
2. **递归前检查**：查询当前状态是否已计算过。
3. **存储结果**：首次计算后保存结果。
4. **返回缓存值**：后续直接返回存储的结果。

# 简单

## [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

> **斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：
>
> ```
> F(0) = 0，F(1) = 1
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1
> ```
>
> 给定 `n` ，请计算 `F(n)` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 2
> 输出：1
> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 3
> 输出：2
> 解释：F(3) = F(2) + F(1) = 1 + 1 = 2
> ```
>
> **示例 3：**
>
> ```
> 输入：n = 4
> 输出：3
> 解释：F(4) = F(3) + F(2) = 2 + 1 = 3
> ```
>
>  
>
> **提示：**
>
> - `0 <= n <= 30`

```cpp
int mem[31];

int fib(int n) {
    memset(mem, -1, sizeof(mem));
    return dfs(n);
}

int dfs(int n) {
    if (mem[n] != -1) {
        return mem[n];
    }
    if (n == 1 || n == 0) {
        mem[n] = n;
        return n;
    }
    mem[n] = dfs(n - 1) + dfs(n - 2);
    return mem[n];
}
```

# 中等

## [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

> 一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
>
> 问总共有多少条不同的路径？
>
>  
>
> **示例 1：**
>
> ![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)
>
> ```
> 输入：m = 3, n = 7
> 输出：28
> ```
>
> **示例 2：**
>
> ```
> 输入：m = 3, n = 2
> 输出：3
> 解释：
> 从左上角开始，总共有 3 条路径可以到达右下角。
> 1. 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向下
> ```
>
> **示例 3：**
>
> ```
> 输入：m = 7, n = 3
> 输出：28
> ```
>
> **示例 4：**
>
> ```
> 输入：m = 3, n = 3
> 输出：6
> ```
>
>  
>
> **提示：**
>
> - `1 <= m, n <= 100`
> - 题目数据保证答案小于等于 `2 * 10^9`

```cpp
int uniquePaths(int m, int n) {
    vector<vector<int>> mem(m + 1, vector<int>(n + 1));
    return dfs(mem, m, n);
}

int dfs(vector<vector<int>>& mem, int m, int n) {
    if (mem[m][n] != 0) {
        return mem[m][n];
    }
    if (m == 0 || n == 0) {
        return 0;
    }
    if (m == 1 && n == 1) {
        mem[m][n] = 1;
        return 1;
    }
    mem[m][n] = dfs(mem, m - 1, n) + dfs(mem, m, n - 1);
    return mem[m][n];
}
```

## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

>  给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。
>
> **子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,1,0,3,2,3]
> 输出：4
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [7,7,7,7,7,7,7]
> 输出：1
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 2500`
> - `-10^4 <= nums[i] <= 10^4`
>
>  
>
> **进阶：**
>
> - 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

```cpp
int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    vector<int> mem(n);
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        ans = max(ans, dfs(nums, mem, i));
    }
    return ans;
}

int dfs(vector<int>& nums, vector<int>& mem, int pos) {
    if (mem[pos] != 0) {
        return mem[pos];
    }
    int ret = 1;
    for (int i = pos + 1; i < nums.size(); ++i) {
        if (nums[i] > nums[pos]) {
            ret = max(ret, dfs(nums, mem, i) + 1);
        }
    }
    mem[pos] = ret;
    return ret;
}
```

## [375. 猜数字大小 II](https://leetcode.cn/problems/guess-number-higher-or-lower-ii/)

> 我们正在玩一个猜数游戏，游戏规则如下：
>
> 1. 我从 `1` 到 `n` 之间选择一个数字。
> 2. 你来猜我选了哪个数字。
> 3. 如果你猜到正确的数字，就会 **赢得游戏** 。
> 4. 如果你猜错了，那么我会告诉你，我选的数字比你的 **更大或者更小** ，并且你需要继续猜数。
> 5. 每当你猜了数字 `x` 并且猜错了的时候，你需要支付金额为 `x` 的现金。如果你花光了钱，就会 **输掉游戏** 。
>
> 给你一个特定的数字 `n` ，返回能够 **确保你获胜** 的最小现金数，**不管我选择那个数字** 。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/09/10/graph.png)
>
> ```
> 输入：n = 10
> 输出：16
> 解释：制胜策略如下：
> - 数字范围是 [1,10] 。你先猜测数字为 7 。
>     - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。
>     - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
>         - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。
>         - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
>         - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
>     - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
>         - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。
>         - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
>             - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。
>             - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
>             - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
>         - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
>             - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。
>             - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
> 在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1
> 输出：0
> 解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。
> ```
>
> **示例 3：**
>
> ```
> 输入：n = 2
> 输出：1
> 解释：有两个可能的数字 1 和 2 。
> - 你可以先猜 1 。
>     - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。
>     - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
> 最糟糕的情况下，你需要支付 $1 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= n <= 200`

```cpp
int mem[205][205];

int getMoneyAmount(int n) {
    return dfs(1, n);
}

int dfs(int left, int right) {
    if (right <= left) {
        return 0;
    }
    if (mem[left][right] != 0) {
        return mem[left][right];
    }
    int ret = INT_MAX;
    for (int i = left; i <= right; ++i) {
        int x = dfs(left, i - 1);
        int y = dfs(i + 1, right);
        ret = min(max(x, y) + i, ret);
    }
    mem[left][right] = ret;
    return ret;
}
```

# 困难

## [329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)

> 给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。
>
> 对于每个单元格，你可以往上，下，左，右四个方向移动。 你 **不能** 在 **对角线** 方向上移动或移动到 **边界外**（即不允许环绕）。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg)
>
> ```
> 输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]
> 输出：4 
> 解释：最长递增路径为 [1, 2, 6, 9]。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg)
>
> ```
> 输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]
> 输出：4 
> 解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。
> ```
>
> **示例 3：**
>
> ```
> 输入：matrix = [[1]]
> 输出：1
> ```
>
>  
>
> **提示：**
>
> - `m == matrix.length`
> - `n == matrix[i].length`
> - `1 <= m, n <= 200`
> - `0 <= matrix[i][j] <= 231 - 1`

```cpp
int dy[4] = {0, 0, 1, -1};
int dx[4] = {1, -1, 0, 0};
int mem[205][205];

int longestIncreasingPath(vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    int ans = 1;
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            ans = max(ans, dfs(matrix, i, j));
        }
    }
    return ans;
}

int dfs(vector<vector<int>>& matrix, int x, int y) {
    if (mem[x][y] != 0) {
        return mem[x][y];
    }
    int m = matrix.size(), n = matrix[0].size();
    int ret = 1;
    for (int k = 0; k < 4; ++k) {
        int nx = x + dx[k], ny = y + dy[k];
        if (nx >= 0 && nx < m && ny >= 0 && ny < n 
            && matrix[nx][ny] > matrix[x][y]) {
            ret = max(dfs(matrix, nx, ny) + 1, ret);
        }
    }
    mem[x][y] = ret;
    return ret;
}
```

