# 简单

## [面试题 17.16. 按摩师](https://leetcode.cn/problems/the-masseuse-lcci/)

> 一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。
>
> **注意：**本题相对原题稍作改动
>
>  
>
> **示例 1：**
>
> ```
> 输入： [1,2,3,1]
> 输出： 4
> 解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。
> ```
>
> **示例 2：**
>
> ```
> 输入： [2,7,9,3,1]
> 输出： 12
> 解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。
> ```
>
> **示例 3：**
>
> ```
> 输入： [2,1,4,5,3,1,1,3]
> 输出： 12
> 解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。
> ```

```cpp
int massage(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) {
        return 0;
    }
    // dp[i][0]选到nums[i]的最长预约事件
    // dp[i][1]未选nums[i]的最长预约事件
    vector<vector<int>> dp(n, vector<int>(2));
    dp[0][0] = nums[0], dp[0][1] = 0;

    for (int i = 1; i < n; ++i) {
        dp[i][0] = dp[i-1][1] + nums[i];
        dp[i][1] = max(dp[i-1][0], dp[i-1][1]);
    }

    return max(dp[n-1][0], dp[n-1][1]);
}
```

# 中等

## [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。
>
>  
>
> **示例 1：**
>
> ```
> 输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。
> ```
>
> **示例 2：**
>
> ```
> 输入：[2,7,9,3,1]
> 输出：12
> 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>      偷窃到的最高金额 = 2 + 9 + 1 = 12 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 100`
> - `0 <= nums[i] <= 400`

```cpp
int rob(vector<int>& nums) {
    int n = nums.size();
    // dp[i][0]偷盗nums[i]的最高金额
    // dp[i][1]不偷nums[i]的最高金额
    vector<vector<int>> dp(n, vector<int>(2));
    dp[0][0] = nums[0], dp[0][1] = 0;

    for (int i = 1; i < n; ++i) {
        dp[i][0] = dp[i-1][1] + nums[i];
        dp[i][1] = max(dp[i-1][0], dp[i-1][1]);
    }

    return max(dp[n-1][0], dp[n-1][1]);
}
```

