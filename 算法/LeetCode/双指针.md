# 简单

## [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。
>
> 
>
> **示例 1:**
>
> ```
> 输入: nums = [0,1,0,3,12]
> 输出: [1,3,12,0,0]
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [0]
> 输出: [0]
> ```
>
> 
>
> **提示**:
>
> - `1 <= nums.length <= 104`
> - `-231 <= nums[i] <= 231 - 1`
>
> 
>
> **进阶：**你能尽量减少完成的操作次数吗？

通过双指针仅维护一个非零数组 (0, left)。

```C++
void moveZeroes(vector<int>& nums) {
    // 双指针确定非零数组，再将零元素数组全部置零
    int left = 0, right = 0;
    while (right < nums.size()) {
        if (nums[right] != 0)
            nums[left++] = nums[right];
        right++;
    }
    while (left < nums.size()) {
        nums[left++] = 0;
    }
}
```

双指针可以用来**数组分块**，用来维护非零(0, left)和零(left, right)两个数组，将上面算法进行优化得到：

```C++
void moveZeroes(vector<int>& nums) {
    // 双指针将数组分块，划分为非零数组和零数组
    int left = 0, right = 0;
    while (right < nums.size()) {
        if (nums[right] != 0)
            swap(nums[left++], nums[right]);
        right++;
    }
}
```

## [1089. 复写零](https://leetcode.cn/problems/duplicate-zeros/)

> 给你一个长度固定的整数数组 `arr` ，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。
>
> 注意：请不要在超过该数组长度的位置写入元素。请对输入的数组 **就地** 进行上述修改，不要从函数返回任何东西。
>
>  
>
> **示例 1：**
>
> ```
> 输入：arr = [1,0,2,3,0,4,5,0]
> 输出：[1,0,0,2,3,0,0,4]
> 解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
> ```
>
> **示例 2：**
>
> ```
> 输入：arr = [1,2,3]
> 输出：[1,2,3]
> 解释：调用函数后，输入的数组将被修改为：[1,2,3]
> ```
>
>  
>
> **提示：**
>
> - `1 <= arr.length <= 10^4`
> - `0 <= arr[i] <= 9`

这题虽然是一道简单题但并不简单。可以自己画图模拟一下从前往后和从后往前。如果再创建一个新的数组，遍历原数组，更新新数组即可，但这样不符合题意。如果从前往后就地在数组上修改会发现产生了覆盖肯定不对。所以考虑从后往前地构造，需要先找到最后一个开始的位置。

```C++
void duplicateZeros(vector<int>& arr) {
    int begin = 0, count = 0;
    while (count < arr.size()) {
        if (arr[begin] == 0) 
            count += 2;
        else
            count++;
        begin++;
    }
    begin--;
	
    // 最后一个数是零，复写后会超出原数组
    int dest = arr.size() - 1;
    if (count > arr.size()) {
        begin--;
        arr[dest--] = 0;
    }

    while (begin >= 0) {
        arr[dest--] = arr[begin];
        if (arr[begin] == 0) 
            arr[dest--] = 0;
        begin--;
    }
}
```

对上面代码还可以进行简单优化，可以发现找从后往前构造的开始位置的`count`就是构建数组的`dest`。

```C++
void duplicateZeros(vector<int>& arr) {
    int cur = 0, dest = -1;
    while (cur < arr.size()) {
        if (arr[cur] == 0)
            dest += 2;
        else
            dest++;
        if (dest >= arr.size() - 1)
            break;
        cur++;
    }
    if (dest == arr.size()) {
        arr[dest - 1] = 0;
        dest -= 2;
        cur--;
    }
    while (cur >= 0) {
        arr[dest--] = arr[cur];
        if (arr[cur] == 0)
            arr[dest--] = 0;
        cur--;
    }
}
```

