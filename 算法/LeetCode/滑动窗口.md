# 中等

## [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长** **子串**的长度。
>
> **子字符串** **是字符串中连续的** **非空** **字符序列。**
>
>  
>
> **示例 1:**
>
> ```
> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> ```
>
> **示例 2:**
>
> ```
> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
> ```
>
> **示例 3:**
>
> ```
> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
> ```
>
>  
>
> **提示：**
>
> - `0 <= s.length <= 5 * 10^4`
> - `s` 由英文字母、数字、符号和空格组成

滑动窗口当区间无重复元素时，添加元素并更新`ans`；有重复元素时，循环删除元素。

```C++
int lengthOfLongestSubstring(string s) {
    int ans = 0;
    int hash[128] = {0};
    int left = 0, right = 0;
    while (right < s.size()) {
        hash[s[right]]++;
        while (hash[s[right]] > 1) {
            hash[s[left++]]--;
        }
        ans = max(ans, right - left + 1);
        right++;
    }
    return ans;
}
```


## [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

> 给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**
>
> 找出该数组中满足其总和大于等于 `target` 的长度最小的 
>
> **子数组**
>
> `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。
>
> 
>
> **示例 1：**
>
> ```
> 输入：target = 7, nums = [2,3,1,2,4,3]
> 输出：2
> 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
> ```
>
> **示例 2：**
>
> ```
> 输入：target = 4, nums = [1,4,4]
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：target = 11, nums = [1,1,1,1,1,1,1,1]
> 输出：0
> ```
>
>  
>
> **提示：**
>
> - `1 <= target <= 10^9`
> - `1 <= nums.length <= 10^5`
> - `1 <= nums[i] <= 10^4`
>
>  
>
> **进阶：**
>
> - 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

滑动窗口当区间和大于等于`target`时，循环删除元素并更新`ans`即可；小于`target`时，添加元素。

```C++
int minSubArrayLen(int target, vector<int>& nums) {
    int left = 0, right = 0;
    int sum = 0, ans = INT_MAX;
    while (right < nums.size()) {
        sum += nums[right];
        while (sum >= target) {
            ans = min(ans, right - left);
            sum -= nums[left++];
        }
        right++;
    }
    return ans == INT_MAX ? 0 : ans;
}
```

## [1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

> 给定一个二进制数组 `nums` 和一个整数 `k`，假设最多可以翻转 `k` 个 `0` ，则返回执行操作后 *数组中连续 `1` 的最大个数* 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2
> 输出：6
> 解释：[1,1,1,0,0,1,1,1,1,1,1]
> 粗体数字从 0 翻转到 1，最长的子数组长度为 6。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
> 输出：10
> 解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
> 粗体数字从 0 翻转到 1，最长的子数组长度为 10。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 10^5`
> - `nums[i]` 不是 `0` 就是 `1`
> - `0 <= k <= nums.length`

统计滑动窗口区间0的个数；大于`k`时，`left`循环左移，保持区间可以翻转后全为1；小于等于`k`时，更新`ans`。

```C++
int longestOnes(vector<int>& nums, int k) {
    int ans = 0, zero = 0;
    int left = 0, right = 0;
    while (right < nums.size()) {
        if (nums[right] == 0)
            zero++;
        while (zero > k)
            if (nums[left++] == 0)
                zero--;
        ans = max(ans, right - left + 1);
        right++;
    }
    return ans;
}
```

## [1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

> 给你一个整数数组 `nums` 和一个整数 `x` 。每一次操作时，你应当移除数组 `nums` 最左边或最右边的元素，然后从 `x` 中减去该元素的值。请注意，需要 **修改** 数组以供接下来的操作使用。
>
> 如果可以将 `x` **恰好** 减到 `0` ，返回 **最小操作数** ；否则，返回 `-1` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,1,4,2,3], x = 5
> 输出：2
> 解释：最佳解决方案是移除后两个元素，将 x 减到 0 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [5,6,7,8,9], x = 4
> 输出：-1
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [3,2,20,1,1,3], x = 10
> 输出：5
> 解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 10^5`
> - `1 <= nums[i] <= 10^4`
> - `1 <= x <= 10^9`

按照题意来做，很难做。转换为求最长的和为sum - x的区间，就可以想到滑动窗口，和这题[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)类似。

```C++
int minOperations(vector<int>& nums, int x) {
    // 正难则反，求最长的和为sum - x的区间
    int sum = 0;
    for (auto i : nums)
        sum += i;
    if (sum < x)
        return -1;

    int target = 0, len = -1;
    int left = 0, right = 0;
    while (right < nums.size()) {
        target += nums[right++];
        while (target > sum - x) {
            target -= nums[left++];                
        }
        if (target == sum - x)
            len = max(right - left, len);
    }
    return len == -1 ? -1 : nums.size() - len;
}
```

