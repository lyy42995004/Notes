# 简单

## [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

> 给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。
>
> **注意：**如果对空文本输入退格字符，文本继续为空。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "ab#c", t = "ad#c"
> 输出：true
> 解释：s 和 t 都会变成 "ac"。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "ab##", t = "c#d#"
> 输出：true
> 解释：s 和 t 都会变成 ""。
> ```
>
> **示例 3：**
>
> ```
> 输入：s = "a#c", t = "b"
> 输出：false
> 解释：s 会变成 "c"，但 t 仍然是 "b"。
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length, t.length <= 200`
> - `s` 和 `t` 只含有小写字母以及字符 `'#'`
>
>  
>
> **进阶：**
>
> - 你可以用 `O(n)` 的时间复杂度和 `O(1)` 的空间复杂度解决该问题吗？

利用栈的思想，构建字符串

```C++
string build(string str) {
    string s;
    for (char ch : str) {
        if (ch == '#') {
            if (s.size() > 0)
                s.pop_back();
        } else {
            s.push_back(ch);
        }
    }
    return s;
}

bool backspaceCompare(string s, string t) {
    return build(s) == build(t);
}
```

## [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

> 给出由小写字母组成的字符串 `s`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。
>
> 在 `s` 上反复执行重复项删除操作，直到无法继续删除。
>
> 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
>
>  
>
> **示例：**
>
> ```
> 输入："abbaca"
> 输出："ca"
> 解释：
> 例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
> ```
>
>  
>
> **提示：**
>
> 1. `1 <= s.length <= 10^5`
> 2. `s` 仅由小写英文字母组成。

从左向右顺次处理字符串，利用`back`， `pop_back` 和`push_back`函数来模拟栈的后入先出。

```C++
string removeDuplicates(string s) {
    string ans;
    for (char ch : s) {
        if (!ans.empty() && ans.back() == ch)
            ans.pop_back();
        else
            ans.push_back(ch);
    }
    return ans;
}
```

# 中等

## [227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)

> 给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。
>
> 整数除法仅保留整数部分。
>
> 你可以假设给定的表达式总是有效的。所有中间结果将在 `[-2^31, 2^31 - 1]` 的范围内。
>
> **注意：**不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "3+2*2"
> 输出：7
> ```
>
> **示例 2：**
>
> ```
> 输入：s = " 3/2 "
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：s = " 3+5 / 2 "
> 输出：5
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 3 * 105`
> - `s` 由整数和算符 `('+', '-', '*', '/')` 组成，中间由一些空格隔开
> - `s` 表示一个 **有效表达式**
> - 表达式中的所有整数都是非负整数，且在范围 `[0, 2^31 - 1]` 内
> - 题目数据保证答案是一个 **32-bit 整数**

- 加号：将数字压入栈；减号：将数字的相反数压入栈；

- 乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果

```C++
int calculate(string s) {
    vector<int> st;
    int n = s.size();
    int num = 0;
    char preSign = '+'; // 记录上一个运算符
    for (int i = 0; i < n; ++i) {
        if (isdigit(s[i]))
            num = num * 10 + (s[i] -'0'); // 不括起来，可能溢出
        if (!isdigit(s[i]) && s[i] != ' ' || i == n - 1) {
            // 一个数字结束 或 最后一个数字
            switch (preSign) {
            case '+':
                st.push_back(num);
                break;
            case '-':
                st.push_back(-num);
                break;
            case '*':
                st.back() *= num;
                break;
            case '/':
                st.back() /= num;
                break;
            }
            preSign = s[i];
            num = 0;
        }
    }
    return accumulate(st.begin(), st.end(), 0);
}
```

