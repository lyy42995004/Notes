# 简单

## [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

> 给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。
>
> **注意：**如果对空文本输入退格字符，文本继续为空。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "ab#c", t = "ad#c"
> 输出：true
> 解释：s 和 t 都会变成 "ac"。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "ab##", t = "c#d#"
> 输出：true
> 解释：s 和 t 都会变成 ""。
> ```
>
> **示例 3：**
>
> ```
> 输入：s = "a#c", t = "b"
> 输出：false
> 解释：s 会变成 "c"，但 t 仍然是 "b"。
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length, t.length <= 200`
> - `s` 和 `t` 只含有小写字母以及字符 `'#'`
>
>  
>
> **进阶：**
>
> - 你可以用 `O(n)` 的时间复杂度和 `O(1)` 的空间复杂度解决该问题吗？

利用栈的思想，构建字符串

```C++
string build(string str) {
    string s;
    for (char ch : str) {
        if (ch == '#') {
            if (s.size() > 0)
                s.pop_back();
        } else {
            s.push_back(ch);
        }
    }
    return s;
}

bool backspaceCompare(string s, string t) {
    return build(s) == build(t);
}
```

## [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

> 给出由小写字母组成的字符串 `s`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。
>
> 在 `s` 上反复执行重复项删除操作，直到无法继续删除。
>
> 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
>
>  
>
> **示例：**
>
> ```
> 输入："abbaca"
> 输出："ca"
> 解释：
> 例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
> ```
>
>  
>
> **提示：**
>
> 1. `1 <= s.length <= 10^5`
> 2. `s` 仅由小写英文字母组成。

从左向右顺次处理字符串，利用`back`， `pop_back` 和`push_back`函数来模拟栈的后入先出。

```C++
string removeDuplicates(string s) {
    string ans;
    for (char ch : s) {
        if (!ans.empty() && ans.back() == ch)
            ans.pop_back();
        else
            ans.push_back(ch);
    }
    return ans;
}
```

# 中等

## [227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)

> 给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。
>
> 整数除法仅保留整数部分。
>
> 你可以假设给定的表达式总是有效的。所有中间结果将在 `[-2^31, 2^31 - 1]` 的范围内。
>
> **注意：**不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "3+2*2"
> 输出：7
> ```
>
> **示例 2：**
>
> ```
> 输入：s = " 3/2 "
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：s = " 3+5 / 2 "
> 输出：5
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 3 * 105`
> - `s` 由整数和算符 `('+', '-', '*', '/')` 组成，中间由一些空格隔开
> - `s` 表示一个 **有效表达式**
> - 表达式中的所有整数都是非负整数，且在范围 `[0, 2^31 - 1]` 内
> - 题目数据保证答案是一个 **32-bit 整数**

- 加号：将数字压入栈；减号：将数字的相反数压入栈；

- 乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果

```C++
int calculate(string s) {
    vector<int> st;
    int n = s.size();
    int num = 0;
    char preSign = '+'; // 记录上一个运算符
    for (int i = 0; i < n; ++i) {
        if (isdigit(s[i]))
            num = num * 10 + (s[i] -'0'); // 不括起来，可能溢出
        if (!isdigit(s[i]) && s[i] != ' ' || i == n - 1) {
            // 一个数字结束 或 最后一个数字
            switch (preSign) {
            case '+':
                st.push_back(num);
                break;
            case '-':
                st.push_back(-num);
                break;
            case '*':
                st.back() *= num;
                break;
            case '/':
                st.back() /= num;
                break;
            }
            preSign = s[i];
            num = 0;
        }
    }
    return accumulate(st.begin(), st.end(), 0);
}
```

## [394. 字符串解码](https://leetcode.cn/problems/decode-string/)

> 给定一个经过编码的字符串，返回它解码后的字符串。
>
> 编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。
>
> 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
>
> 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "3[a]2[bc]"
> 输出："aaabcbc"
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "3[a2[c]]"
> 输出："accaccacc"
> ```
>
> **示例 3：**
>
> ```
> 输入：s = "2[abc]3[cd]ef"
> 输出："abcabccdcdcdef"
> ```
>
> **示例 4：**
>
> ```
> 输入：s = "abc3[cd]xyz"
> 输出："abccdcdcdxyz"
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 30`
> - `s` 由小写英文字母、数字和方括号 `'[]'` 组成
> - `s` 保证是一个 **有效** 的输入。
> - `s` 中所有整数的取值范围为 `[1, 300]` 

- 数字：提取出这个数字，放入“数字栈”中。

- '['：将空串放入“字符串栈”中
- ']'：记录重复后的栈顶元素，出栈，再添加到“字符串栈”栈顶的字符串后面。
- 单独的字符：提取出这个字符，添加到“字符串栈”栈顶的字符串后面。

```C++
string decodeString(string s) {
    vector<int> v;    // 数字栈
    stack<string> st; // 字符串栈
    st.push("");
    for (int j = 0; j < s.size(); ++j) {
        if (isdigit(s[j])) { // 放入“数字栈”中
            if (j == 0 || !isdigit(s[j - 1]))
                v.push_back(s[j] - '0');
            else
                v.back() = v.back() * 10 + (s[j] - '0');
        } else if (s[j] == '[') { // 将空串放入“字符串栈”中
            st.push("");
        } else if (s[j] == ']') { // 将栈顶元素重复之后，放入“字符串栈”中
            string tmp;
            for (int i = 0; i < v.back(); ++i)
                tmp += st.top();
            v.pop_back();
            st.pop();
            st.top() += tmp;
        } else {  // 将字符串放入“字符串栈”中
            st.top() += s[j];
        }
    }
    string ans;
    while (!st.empty()) {
        ans = st.top() + ans;
        st.pop();
    }
    return ans;
}
```

