# [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。
>
> 图示两个链表在节点 `c1` 开始相交**：**
>
> [<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img" style="zoom:50%;" />](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)
>
> 题目数据 **保证** 整个链式结构中不存在环。
>
> **注意**，函数返回结果后，链表必须 **保持其原始结构** 。
>
> **自定义评测：**
>
> **评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：
>
> - `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
> - `listA` - 第一个链表
> - `listB` - 第二个链表
> - `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
> - `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数
>
> 评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。
>
>  
>
> **示例 1：**
>
> [<img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img" style="zoom:50%;" />](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)
>
> ```
> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
> 输出：Intersected at '8'
> 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
> 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
> 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
> — 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
> ```
>
>  
>
> **示例 2：**
>
> [<img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img" style="zoom:50%;" />](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)
>
> ```
> 输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
> 输出：Intersected at '2'
> 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
> 从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
> 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
> ```
>
> **示例 3：**
>
> [<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img" style="zoom:50%;" />](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)
>
> ```
> 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
> 输出：No intersection
> 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
> 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
> 这两个链表不相交，因此返回 null 。
> ```
>
>  
>
> **提示：**
>
> - `listA` 中节点数目为 `m`
> - `listB` 中节点数目为 `n`
> - `1 <= m, n <= 3 * 10^4`
> - `1 <= Node.val <= 10^5`
> - `0 <= skipA <= m`
> - `0 <= skipB <= n`
> - 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
> - 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`
>
>  
>
> **进阶：**你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？

**哈希**：判重找到第一个重复出现的地址。

```cpp
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    unordered_set<ListNode* > hash;
    while (headA) {
        hash.insert(headA);
        headA = headA->next;
    }
    while (headB) {
        if (hash.count(headB))
            return headB;
        headB = headB->next;
    }
    return nullptr;
}
```

**双指针**

- 指针 `curA` 先遍历链表 `A` 的不相交部分，长度为 `a - c`；然后遍历相交部分，当遍历到相交部分末尾时，如果还没有和 `curB` 相遇，它会跳到链表 `B` 的头部继续遍历。此时它总共遍历的节点数为 `a - c + b - c`。

- 指针 `curB` 先遍历链表 `B` 的不相交部分，长度为 `b - c`；然后遍历相交部分，当遍历到相交部分末尾时，如果还没有和 `curA` 相遇，它会跳到链表 `A` 的头部继续遍历。此时它总共遍历的节点数为 `b - c + a - c`。
- 如果没有相交节点，`c = 0`，`curA`和`curB`会在都为空时相遇，并退出循环。

[图片原题解](https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/12624/intersection-of-two-linked-lists-shuang-zhi-zhen-l)

<img src="https://pic.leetcode-cn.com/1615224578-EBRtwv-Picture1.png" style="zoom: 33%;" />

```C++
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    if (headA == nullptr || headB == nullptr)
        return nullptr;

    ListNode* curA = headA, * curB = headB;
    while (curA != curB) {
        curA = curA == nullptr ? headB : curA->next;
        curB = curB == nullptr ? headA : curB->next;
    }
    return curA;
}
```

# [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。
>
>  
>
> **示例 1：**
>
> <img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img" style="zoom: 67%;" />
>
> ```
> 输入：head = [1,2,3,4,5]
> 输出：[5,4,3,2,1]
> ```
>
> **示例 2：**
>
> <img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img" style="zoom: 67%;" />
>
> ```
> 输入：head = [1,2]
> 输出：[2,1]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = []
> 输出：[]
> ```
>
>  
>
> **提示：**
>
> - 链表中节点的数目范围是 `[0, 5000]`
> - `-5000 <= Node.val <= 5000`
>
>  
>
> **进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

**迭代**

```C++
ListNode* reverseList(ListNode* head) {
    ListNode* cur = head;
    ListNode* prev = nullptr;
    while (cur) {
        ListNode* next = cur->next;
        cur->next = prev;
        prev = cur;
        cur = next;
    }
    return prev;
}
```

**递归**

```C++
ListNode* reverseList(ListNode* head) {
    if (head == nullptr || head->next == nullptr)
        return head;
    ListNode* new_head = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return new_head;
}
```

# [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

> 给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表如果是，返回 `true` ；否则，返回 `false`。
>
> **回文** 序列是向前和向后读都相同的序列
>
>  
>
> **示例 1：**
>
> <img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img" style="zoom:67%;" />
>
> ```
> 输入：head = [1,2,2,1]
> 输出：true
> ```
>
> **示例 2：**
>
> <img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img" style="zoom: 67%;" />
>
> ```
> 输入：head = [1,2]
> 输出：false
> ```
>
>  
>
> **提示：**
>
> - 链表中节点数目在范围`[1, 10^5]` 内
> - `0 <= Node.val <= 9`
>
>  
>
> **进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？

**数组模拟**

```C++
bool isPalindrome(ListNode* head) {
    vector<int> nums;
    while (head) {
        nums.push_back(head->val);
        head = head->next;
    }
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        if (nums[left] != nums[right])
            return false;
        left++;
        right--;
    }
    return true;
}
```

# [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

> 给你一个链表的头节点 `head` ，判断链表中是否有环。
>
> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。
>
> *如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。
>
> 
>
> **示例 1：**
>
> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom: 67%;" />
>
> ```
> 输入：head = [3,2,0,-4], pos = 1
> 输出：true
> 解释：链表中有一个环，其尾部连接到第二个节点。
> ```
>
> **示例 2：**
>
> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img" style="zoom: 67%;" />
>
> ```
> 输入：head = [1,2], pos = 0
> 输出：true
> 解释：链表中有一个环，其尾部连接到第一个节点。
> ```
>
> **示例 3：**
>
> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img" style="zoom:67%;" />
>
> ```
> 输入：head = [1], pos = -1
> 输出：false
> 解释：链表中没有环。
> ```
>
> 
>
> **提示：**
>
> - 链表中节点的数目范围是 `[0, 10^4]`
> - `-10^5 <= Node.val <= 10^5`
> - `pos` 为 `-1` 或者链表中的一个 **有效索引** 。
>
> 
>
> **进阶：**你能用 `O(1)`（即，常量）内存解决此问题吗？

**哈希**

- 如果链表中存在环，链表中有重复的地址出现；如果没有环，则退出循环。

```C++
bool hasCycle(ListNode *head) {
    unordered_set<ListNode* > hash;
    while (head) {
        if (hash.count(head))
            return true;
        hash.insert(head);
        head = head->next;
    }
    return false;
}
```

**快慢指针**

- 如果链表中存在环，那么 `fast` 指针会先进入环，然后在环中不断循环。由于 `fast` 指针移动速度比 `slow` 指针快，最终 `fast` 指针会追上 `slow` 指针，即 `slow` 指针和 `fast` 指针会相遇。
- 如果链表中不存在环，那么 `fast` 指针会先到达链表的末尾（即 `fast->next` 或 `fast->next->next` 为 `nullptr`），此时循环结束，说明链表中不存在环。

```C++
bool hasCycle(ListNode *head) {
    if (head == nullptr)
        return false;
    ListNode* slow = head, *fast = head;
    while (fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)
            return true;
    }
    return false;
}
```

# [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

> 给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*
>
> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。
>
> **不允许修改** 链表。
>
> 
>
> **示例 1：**
>
> <img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom:67%;" />
>
> ```
> 输入：head = [3,2,0,-4], pos = 1
> 输出：返回索引为 1 的链表节点
> 解释：链表中有一个环，其尾部连接到第二个节点。
> ```
>
> **示例 2：**
>
> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img" style="zoom:67%;" />
>
> ```
> 输入：head = [1,2], pos = 0
> 输出：返回索引为 0 的链表节点
> 解释：链表中有一个环，其尾部连接到第一个节点。
> ```
>
> **示例 3：**
>
> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img" style="zoom:67%;" />
>
> ```
> 输入：head = [1], pos = -1
> 输出：返回 null
> 解释：链表中没有环。
> ```
>
> 
>
> **提示：**
>
> - 链表中节点的数目范围在范围 `[0, 10^4]` 内
> - `-105 <= Node.val <= 10^5`
> - `pos` 的值为 `-1` 或者链表中的一个有效索引
>
> 
>
> **进阶：**你是否可以使用 `O(1)` 空间解决此题？

**哈希**

- 如果链表中存在环，链表中第一次重复出现的地址就是入环的第一个节点；如果没有环，则退出循环。

```C++
ListNode *detectCycle(ListNode *head) {
    unordered_set<ListNode* > hash;
    while (head) {
        if (hash.count(head))
            return head;
        hash.insert(head);
        head = head->next;
    }
    return nullptr;
}
```

**快慢指针**

设链表头节点到环入口节点的距离为 `a`，环入口节点到快慢指针相遇节点的距离为 `b`，相遇节点再到环入口节点的距离为 `c`。

- 当快慢指针相遇时，`slow` 指针走过的距离为 `a + b`，`fast` 指针走过的距离为 `a + b + k * (b + c)`（`k` 为 `fast` 指针在环内绕的圈数，`k >= 1`）。
- 由于 `fast` 指针速度是 `slow` 指针的两倍，所以有 `2 * (a + b) = a + b + k * (b + c)`，化简可得 **`a = (k - 1) * (b + c) + c`**，既`a`等于`c`加上`k - 1`圈的长度。
- 这意味着从链表头节点和快慢指针相遇节点同时出发，以相同速度前进，它们会在环的入口节点相遇。

<img src="https://s2.loli.net/2025/01/25/M2g8pxshA791Ezy.png" style="zoom: 50%;" />

```C++
ListNode *detectCycle(ListNode *head) {
    if (head == nullptr)
        return nullptr;
    ListNode* slow = head, *fast = head;
    while (fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            while (head != slow) {
                head = head->next;
                slow = slow->next;
            }
            return slow;
        }
    }
    return nullptr;
}
```
