## [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

> 给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。
>
>  
>
> **示例 1：**
>
> <img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [1,null,2,3]
> 输出：[1,3,2]
> ```
>
> **示例 2：**
>
> ```
> 输入：root = []
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：root = [1]
> 输出：[1]
> ```
>
>  
>
> **提示：**
>
> - 树中节点数目在范围 `[0, 100]` 内
> - `-100 <= Node.val <= 100`
>
>  
>
> **进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

**递归**

```cpp
vector<int> inorderTraversal(TreeNode* root) {
   vector<int> ans;
   inorder(root, ans);
   return ans; 
}

void inorder(TreeNode* root, vector<int>& ans) {
    if (root == nullptr) {
        return;
    }
    inorder(root->left, ans);
    ans.push_back(root->val);
    inorder(root->right, ans);
}
```

**迭代**

```cpp
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> ans;
    stack<TreeNode*> st;
    TreeNode* cur = root;
    while (cur || !st.empty()) {
        while (cur) {
            st.push(cur);
            cur = cur->left;
        }
        TreeNode* top = st.top();
        st.pop();
        ans.push_back(top->val);
        cur = top->right;
    }
    return ans;
}
```

## [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

> 给定一个二叉树 `root` ，返回其最大深度。
>
> 二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)
>
>  
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：3
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [1,null,2]
> 输出：2
> ```
>
>  
>
> **提示：**
>
> - 树中节点的数量在 `[0, 10^4]` 区间内。
> - `-100 <= Node.val <= 100`

**DFS**

```cpp
int maxDepth(TreeNode* root) {
    if (root == nullptr) {
        return 0;
    }
    return max(maxDepth(root->left), maxDepth(root->right)) + 1;
}
```

## [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。
>
>  
>
> **示例 1：**
>
> ```
> 输入：root = [4,2,7,1,3,6,9]
> 输出：[4,7,2,9,6,3,1]
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [2,1,3]
> 输出：[2,3,1]
> ```
>
> **示例 3：**
>
> ```
> 输入：root = []
> 输出：[]
> ```
>
>  
>
> **提示：**
>
> - 树中节点数目范围在 `[0, 100]` 内
> - `-100 <= Node.val <= 100`

```cpp
TreeNode* invertTree(TreeNode* root) {
    if (root == nullptr) {
        return nullptr;
    }
    TreeNode* left = invertTree(root->left);
    TreeNode* right = invertTree(root->right);
    root->left = right;
    root->right = left;
    return root;
}
```

## [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。
>
>  
>
> **示例 1：**
>
> ![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)
>
> ```
> 输入：root = [1,2,2,3,4,4,3]
> 输出：true
> ```
>
> **示例 2：**
>
> ![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)
>
> ```
> 输入：root = [1,2,2,null,3,null,3]
> 输出：false
> ```
>
>  
>
> **提示：**
>
> - 树中节点数目在范围 `[1, 1000]` 内
> - `-100 <= Node.val <= 100`
>
>  
>
> **进阶：**你可以运用递归和迭代两种方法解决这个问题吗？

**递归**

```cpp
bool isSymmetric(TreeNode* root) {
    return check(root->left, root->right);
}

bool check(TreeNode* left, TreeNode* right) {
    if (left == nullptr && right == nullptr) {
        return true;
    }
    if (left == nullptr || right == nullptr) {
        return false;
    }
    if (left->val != right->val) {
        return false;
    }
    return (check(left->left, right->right) && check(left->right, right->left));
}
```

## [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

> 给你一棵二叉树的根节点，返回该树的 **直径** 。
>
> 二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。
>
> 两节点之间路径的 **长度** 由它们之间边数表示。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)
>
> ```
> 输入：root = [1,2,3,4,5]
> 输出：3
> 解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [1,2]
> 输出：1
> ```
>
>  
>
> **提示：**
>
> - 树中节点数目在范围 `[1, 10^4]` 内
> - `-100 <= Node.val <= 100`

```cpp
int ans;

int diameterOfBinaryTree(TreeNode* root) {
    dfs(root);
    return ans - 1;
}

int dfs(TreeNode* root){
    if (root == nullptr) {
        return 0;
    }
    int l = dfs(root->left);
    int r = dfs(root->right);
    ans = max(ans, l+r+1);
    return max(l, r) + 1;
}
```

## [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[3],[9,20],[15,7]]
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [1]
> 输出：[[1]]
> ```
>
> **示例 3：**
>
> ```
> 输入：root = []
> 输出：[]
> ```
>
> 
>
> **提示：**
>
> - 树中节点数目在范围 `[0, 2000]` 内
> - `-1000 <= Node.val <= 1000`

**BFS**

```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    if (root == nullptr) {
        return vector<vector<int>>();
    }
    vector<vector<int>> ans;
    queue<TreeNode*> q;
    int sz = 1;
    q.push(root);
    while (!q.empty()) {
        vector<int> v;
        while (sz--) {
            TreeNode* t = q.front();
            v.push_back(t->val);
            q.pop();
            if (t->left) {
                q.push(t->left);
            }
            if (t->right) {
                q.push(t->right);
            }
        }
        ans.push_back(v);
        sz = q.size();
    }
    return ans;
}
```

​	