**双指针算法应用**

1. **有序数组**中的问题：在排序数组中查找满足某些条件的元素对。

- 典型问题：
  - 两数之和（Two Sum）在有序数组中的实现。
  - 判断数组中是否存在某些和为指定值的元素对。
- 方法： **设置一个指针从头开始，另一个从尾开始，根据当前的和调整指针移动方向。**


2. **区间**问题：查找数组或字符串中的子区间。

- 典型问题：
  - 最小覆盖子串（Sliding Window问题）。
  - 最大连续子数组和或长度满足某条件的子数组。
- 方法： **两个指针分别表示区间的左右端点，动态调整区间长度以满足条件。**


3. **链表**相关问题：**快慢指针**用于处理链表问题。

- 典型问题：
  - 判断链表是否有环。
  - 找到链表的中间节点。
  - 删除链表的倒数第 k 个节点。
- 方法： **一个指针快步前进（一次走两步），另一个慢速前进（一次走一步）。**


4. **排序与归并**相关问题：合并两个有序数组或链表。

- 典型问题：
  - 合并两个有序数组。
  - 找两个有序数组的中位数。
- 方法： **两个指针分别指向两个数组的当前比较位置，逐步合并。**


5. **双向遍历**问题：从数据结构的两端逐步向中心靠拢。

- 典型问题：
  - 验证字符串是否是回文。
  - 盛最多水的容器问题（双指针找最大面积）。
- **方法：** **两个指针从数据结构两端开始，逐步根据条件移动。**

6. **跳跃型**问题：在某些情况下动态调整指针的移动步数。

- 典型问题：
  - 最小覆盖子串。
  - 移动零或调整数组顺序。
- **方法：** **左指针慢速处理有效区域，右指针快速扩展范围。**

# [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [0,1,0,3,12]
> 输出: [1,3,12,0,0]
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [0]
> 输出: [0]
> ```
>
>  
>
> **提示**:
>
> - `1 <= nums.length <= 10^4`
> - `-2^31 <= nums[i] <= 2^31 - 1`
>
>  
>
> **进阶：**你能尽量减少完成的操作次数吗？

通过一个慢指针`l`记录非零数组区间右边界，一个快指针`r`来遍历数组不断更新非零数组。

```C++
void moveZeroes(vector<int>& nums) {
    // l维持一个非零数组区间
    int l = 0, r = 0;
    while (r < nums.size()) {
        if (nums[r] != 0) 
            swap(nums[l++], nums[r]);
        r++;
    }
}
```

# [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

> 给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。
>
> 找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。
>
> 返回容器可以储存的最大水量。
>
> **说明：**你不能倾斜容器。
>
>  
>
> **示例 1：**
>
> <img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" style="zoom: 67%;" />
>
> ```
> 输入：[1,8,6,2,5,4,8,3,7]
> 输出：49 
> 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
> ```
>
> **示例 2：**
>
> ```
> 输入：height = [1,1]
> 输出：1
> ```
>
>  
>
> **提示：**
>
> - `n == height.length`
> - `2 <= n <= 10^5`
> - `0 <= height[i] <= 10^4`

双指针为数组两个端点，不断计算区间的容量取最大值。采用**贪心**的思想将缩小区间，如果每次更新容器的最小的

边，确保较大的一边不变，容量的最大值不会错过。可以看一下LeetCode官方题解，讲的比较详细。

```C++
int maxArea(vector<int>& height) {
    int ans = 0;
    int l = 0, r = height.size() - 1;
    while (l < r) {
        ans = max(ans, min(height[l], height[r]) * (r - l));
        // 让最小边变大
        if (height[l] < height[r]) l++;
        else r--;
    }
    return ans;
}
```

# [15. 三数之和](https://leetcode.cn/problems/3sum/)

> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。
>
> **注意：**答案中不可以包含重复的三元组。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [-1,0,1,2,-1,-4]
> 输出：[[-1,-1,2],[-1,0,1]]
> 解释：
> nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
> nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
> nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
> 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
> 注意，输出的顺序和三元组的顺序并不重要。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,1,1]
> 输出：[]
> 解释：唯一可能的三元组和不为 0 。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [0,0,0]
> 输出：[[0,0,0]]
> 解释：唯一可能的三元组和为 0 。
> ```
>
>  
>
> **提示：**
>
> - `3 <= nums.length <= 3000`
> - `-10^5 <= nums[i] <= 10^5`

按照题意一开始想到的肯定是三层枚举＋集合去重，但时间和空间复杂度都太高了，所以要**转换思路**将三数之和化为两数之和。

**通过确定第一个数将它的相反数作为两数之和的`target`，排序来方便双指针查找两数之和。**这其中还有很多细节，主要就是避免重复记录：

- `nums[i] <= 0`，只需要统计这种情况，`nums[i] > 0`在统计小于的情况时已经统计过了。

- `num[i] != nums[i - 1]`，避免重复记录之前的结果。

- `int l = i + 1`，左指针从`i+1`开始，避免重复记录。
- 循环去重`l，r`。

```C++
vector<vector<int>> threeSum(vector<int>& nums) {
        // 排序 + 双指针
        vector<vector<int>> ans;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); ++i) {
            // 转化为两数之和
            int target = -nums[i];
            // 只统计nums[i] < 0的情况
            if (target < 0)
                break;
            if (i != 0 && nums[i] == nums[i - 1])
                continue;
            // 左指针从i+1开始，避免重复
            int l = i + 1, r = nums.size() - 1;
            while (l < r) {
                int sum = nums[l] + nums[r];
                if (sum > target) {
                    r--;
                } else if(sum < target) {
                    l++;
                } else {
                    ans.push_back({nums[i], nums[l++], nums[r--]});
                    // 去重l，r
                    while (l < r && nums[l] == nums[l - 1])
                        l++;
                    while (l < r && nums[r] == nums[r + 1])
                        r--;
                }
            }
        }
        return ans;
    }
```

# [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)
>
> ```
> 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
> 输出：6
> 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
> ```
>
> **示例 2：**
>
> ```
> 输入：height = [4,2,0,3,2,5]
> 输出：9
> ```
>
>  
>
> **提示：**
>
> - `n == height.length`
> - `1 <= n <= 2 * 10^4`
> - `0 <= height[i] <= 10^5`

## 解法1

**看到困难题不要害怕，一步一步分析就能做出来，如果按照题意来比较麻烦，就要考虑转化题意。**这个解法是我自己做出来的，可能有些麻烦，但是做题是的思路可以参考一下。通过计算一个一个区间的储水量，最后还要反过来计算没算上的区间。下面是我做题时的思路：

首先把指针`l`设为左边界，`r`不断迭代直到遍历完数组。**有几个问题思考明白了就可以写代码了**：

- 左边界满足什么条件：大于0即可。

- 右边界满足什么条件：大于等于左边界时。
- 一个区间什么时候更新：得到右边界后，区间确定，计算区间储水量，再更新左边界为之前的右边界即可。

上面有一个问题就是如果最后一个左边界没有找到对应的右边界，就会有一段区间没有记录上，所以需要再反过来计算一下这个区间。

```C++
int trap(vector<int>& height) {
    int l = 0, r = 0;
    while (l < height.size() && height[l] == 0)
        l++;
    r = l + 1;

    int ans = 0;
    int tmp = 0; // 记录区间多余块
    while (r < height.size()) {
        if (height[r] >= height[l]) { // 更新左边界，记录区间储水量
            ans += (r - l - 1) * min(height[r], height[l]);
            ans -= tmp;
            tmp = 0;
            l = r;
        } else {
            tmp += height[r];
        }
        r++;
    }
    // 最后一个部分没算上
    if (l != r) {
        int l_last = l;
        r = height.size() - 1;
        while (r >= 0 && height[r] == 0)
            r--;
        l = r - 1;

        tmp = 0;
        while (l >= l_last) {
            if (height[l] >= height[r]) {
                ans += (r - l - 1) * min(height[r], height[l]);
                ans -= tmp;
                tmp = 0;
                r = l;
            } else {
                tmp += height[l];
            }
            l--;                
        }
    }
    return ans;
}
```

## 解法2（推荐）

使用两个指针 `l` 和 `r` 分别指向数组的起始和结束位置，同时使用 `l_max` 和 `r_max` 分别记录左侧和右侧的最大高度。在每次循环中，更新 `l_max` 和 `r_max`，比较左右高度：

- 如果 `height[l] < height[r]`，说明当前位置的雨水量由左侧的最大高度决定，因此计算 `l_max - height[l]` 并累加到结果中，然后将左指针 `l` 右移一位。
- 否则，说明当前位置的雨水量由右侧的最大高度决定，因此计算 `r_max - height[r]` 并累加到结果中，然后将右指针 `r` 左移一位。

```C++
int trap(vector<int>& height) {
    int ans = 0;
    int l = 0, r = height.size() - 1;
    int l_max = 0, r_max = 0;

    while (l < r) {
        l_max = max(height[l], l_max);
        r_max = max(height[r], r_max);

        if (height[l] < height[r]) {
            ans += l_max - height[l];
            l++;
        } else {
            ans += r_max - height[r];
            r--;
        }
    }
    return ans;
}
```
