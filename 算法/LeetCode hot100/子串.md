# [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

> 给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。
>
> 子数组是数组中元素的连续非空序列。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,1,1], k = 2
> 输出：2
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,2,3], k = 3
> 输出：2
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 2 * 10^4`
> - `-1000 <= nums[i] <= 1000`
> - `-10^7 <= k <= 10^7`

```C++
 int subarraySum(vector<int>& nums, int k) {
    int ans = 0;
    int sum = 0;
    unordered_map<int, int> hash;
    hash[0] = 1;
    for (int i = 0; i < nums.size(); ++i) {
        sum += nums[i];
        if (hash.count(sum - k))
            ans += hash[sum - k];
        hash[sum]++;
    }
    return ans;
}
```

最容易想到的肯定是两个`for`循环枚举所有子数组（O(n^2)），但是试一下会发现超时了。

我想到了前缀和可以用来数组区间和的计算，但是没做出来看的题解，采取**前缀和+哈希**可以把时间复杂度优化到O(n)。思想就是：

通过`sum`统计前缀和，并通过哈希表进行计数统计。**当`sumPrefix[i] - sumPrefix[j] = 区间i到j的和 = k`**
**时（前缀数组的定义），每有`一个前缀和的值 = sum - k`就会有一个区间也就是子数组的和等于`k`。**
